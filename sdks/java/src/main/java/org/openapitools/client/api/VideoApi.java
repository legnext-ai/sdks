/*
 * Midjourney api-unofficial by Legnext.ai
 * # **Legnext.ai Midjourney API: The Ultimate AI Image Generation Toolkit**  Unlock the full creative potential of Midjourney directly within your applications and development workflows using the **Legnext.ai Midjourney API (Unofficial)**. This comprehensive collection offers a ready-to-integrate solution for professional image and video creation, manipulation, and high-fidelity upscaling.  We provide developers with **stable, high-performance API access** to the Midjourney model. Crucially, integrating our service requires **no Midjourney account**, eliminating the hassle of managing official subscriptions or Discord interactions. Our toolkit simplifies the entire text-to-image process, supporting complex prompts, aspect ratio adjustments, and advanced style parameters.  Focus on innovation while we handle the AI infrastructure. Start building scalable, visually stunning applications today with reliable access to the worldâ€™s leading generative AI model.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.ApiV1JobJobIdGet200Response;
import org.openapitools.client.model.TaskResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class VideoApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public VideoApi() {
        this(Configuration.getDefaultApiClient());
    }

    public VideoApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for apiV1ExtendVideoPost
     * @param xApiKey  (optional)
     * @param body  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call apiV1ExtendVideoPostCall(@javax.annotation.Nullable String xApiKey, @javax.annotation.Nullable Object body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/v1/extend-video";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (xApiKey != null) {
            localVarHeaderParams.put("x-api-key", localVarApiClient.parameterToString(xApiKey));
        }


        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call apiV1ExtendVideoPostValidateBeforeCall(@javax.annotation.Nullable String xApiKey, @javax.annotation.Nullable Object body, final ApiCallback _callback) throws ApiException {
        return apiV1ExtendVideoPostCall(xApiKey, body, _callback);

    }

    /**
     * Extend Video
     * ## Extend Video Duration with Seamless Continuation  Add additional frames to extend the duration of generated videos. Creates smooth continuations that seamlessly flow from the original video.  ### How it Works  Select a previously generated video and optionally provide a prompt to guide the extension. The API analyzes the video&#39;s motion and content, then generates additional frames that naturally continue the sequence. Each extension adds 4 seconds.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original video generation task      - &#x60;videoNo&#x60; - Video number to extend (0, 1, 2, or 3)      - &#x60;prompt&#x60; - Optional prompt to guide the extension (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The extended video will be sent to your callback URL when complete (typically 3-5 minutes).  ### Use Cases  - Create longer videos from initial 4-second generations      - Extend successful animations for more content      - Build sequential video narratives      - Generate longer social media content      - Create extended motion sequences       ### Tips  - Each extension adds 4 seconds to the video      - Can extend up to 4 times (maximum 20 seconds total: 4+4+4+4+4)      - Prompt helps guide what happens in the extended portion      - Extension quality depends on the source video&#39;s clarity and motion      - Works with both text-generated and image-animated videos
     * @param xApiKey  (optional)
     * @param body  (optional)
     * @return TaskResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public TaskResponse apiV1ExtendVideoPost(@javax.annotation.Nullable String xApiKey, @javax.annotation.Nullable Object body) throws ApiException {
        ApiResponse<TaskResponse> localVarResp = apiV1ExtendVideoPostWithHttpInfo(xApiKey, body);
        return localVarResp.getData();
    }

    /**
     * Extend Video
     * ## Extend Video Duration with Seamless Continuation  Add additional frames to extend the duration of generated videos. Creates smooth continuations that seamlessly flow from the original video.  ### How it Works  Select a previously generated video and optionally provide a prompt to guide the extension. The API analyzes the video&#39;s motion and content, then generates additional frames that naturally continue the sequence. Each extension adds 4 seconds.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original video generation task      - &#x60;videoNo&#x60; - Video number to extend (0, 1, 2, or 3)      - &#x60;prompt&#x60; - Optional prompt to guide the extension (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The extended video will be sent to your callback URL when complete (typically 3-5 minutes).  ### Use Cases  - Create longer videos from initial 4-second generations      - Extend successful animations for more content      - Build sequential video narratives      - Generate longer social media content      - Create extended motion sequences       ### Tips  - Each extension adds 4 seconds to the video      - Can extend up to 4 times (maximum 20 seconds total: 4+4+4+4+4)      - Prompt helps guide what happens in the extended portion      - Extension quality depends on the source video&#39;s clarity and motion      - Works with both text-generated and image-animated videos
     * @param xApiKey  (optional)
     * @param body  (optional)
     * @return ApiResponse&lt;TaskResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TaskResponse> apiV1ExtendVideoPostWithHttpInfo(@javax.annotation.Nullable String xApiKey, @javax.annotation.Nullable Object body) throws ApiException {
        okhttp3.Call localVarCall = apiV1ExtendVideoPostValidateBeforeCall(xApiKey, body, null);
        Type localVarReturnType = new TypeToken<TaskResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Extend Video (asynchronously)
     * ## Extend Video Duration with Seamless Continuation  Add additional frames to extend the duration of generated videos. Creates smooth continuations that seamlessly flow from the original video.  ### How it Works  Select a previously generated video and optionally provide a prompt to guide the extension. The API analyzes the video&#39;s motion and content, then generates additional frames that naturally continue the sequence. Each extension adds 4 seconds.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original video generation task      - &#x60;videoNo&#x60; - Video number to extend (0, 1, 2, or 3)      - &#x60;prompt&#x60; - Optional prompt to guide the extension (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The extended video will be sent to your callback URL when complete (typically 3-5 minutes).  ### Use Cases  - Create longer videos from initial 4-second generations      - Extend successful animations for more content      - Build sequential video narratives      - Generate longer social media content      - Create extended motion sequences       ### Tips  - Each extension adds 4 seconds to the video      - Can extend up to 4 times (maximum 20 seconds total: 4+4+4+4+4)      - Prompt helps guide what happens in the extended portion      - Extension quality depends on the source video&#39;s clarity and motion      - Works with both text-generated and image-animated videos
     * @param xApiKey  (optional)
     * @param body  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call apiV1ExtendVideoPostAsync(@javax.annotation.Nullable String xApiKey, @javax.annotation.Nullable Object body, final ApiCallback<TaskResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = apiV1ExtendVideoPostValidateBeforeCall(xApiKey, body, _callback);
        Type localVarReturnType = new TypeToken<TaskResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for apiV1JobJobIdGet
     * @param jobId  (required)
     * @param xApiKey  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call apiV1JobJobIdGetCall(@javax.annotation.Nonnull String jobId, @javax.annotation.Nullable String xApiKey, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v1/job/{job_id}"
            .replace("{" + "job_id" + "}", localVarApiClient.escapeString(jobId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (xApiKey != null) {
            localVarHeaderParams.put("x-api-key", localVarApiClient.parameterToString(xApiKey));
        }


        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call apiV1JobJobIdGetValidateBeforeCall(@javax.annotation.Nonnull String jobId, @javax.annotation.Nullable String xApiKey, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'jobId' is set
        if (jobId == null) {
            throw new ApiException("Missing the required parameter 'jobId' when calling apiV1JobJobIdGet(Async)");
        }

        return apiV1JobJobIdGetCall(jobId, xApiKey, _callback);

    }

    /**
     * Get task response
     * ## Retrieve Job Status and Results  Query the status and results of any task using its job ID. Use this to check progress, retrieve completed results, or diagnose failures.  ### How it Works  Provide a job ID from any previous API request. The API returns the current task status, progress information, and results (if completed). Poll this endpoint to track long-running tasks.  ### Required Parameters  - &#x60;job_id&#x60; - UUID of the task (passed in URL path)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns complete task information including:  - &#x60;status&#x60; - Current status: pending, staged, processing, failed, or completed      - &#x60;output&#x60; - Generated images/videos (null until completed)      - &#x60;meta&#x60; - Timestamps, usage information, processing details      - &#x60;error&#x60; - Error details if status is \&quot;failed\&quot;      - &#x60;logs&#x60; - Processing logs and progress updates       ### Status Values  - **pending**: Task queued, waiting to start      - **staged**: Task prepared, about to begin processing      - **processing**: Actively generating (includes progress percentage in logs)      - **completed**: Successfully finished, results available in output field      - **failed**: Processing failed, check error field for details       ### Use Cases  - Poll for task completion if not using webhooks      - Retrieve results for tasks completed days/weeks ago      - Debug failed tasks by examining error messages      - Monitor processing progress for long-running jobs      - Retrieve task history and usage information       ### Tips  - Job IDs are permanent - tasks can be retrieved anytime      - Poll every 10-30 seconds for pending tasks (avoid excessive polling)      - Webhook callbacks are more efficient than polling      - Failed tasks include detailed error messages for debugging      - Completed tasks retain all generation parameters in the input field
     * @param jobId  (required)
     * @param xApiKey  (optional)
     * @return ApiV1JobJobIdGet200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public ApiV1JobJobIdGet200Response apiV1JobJobIdGet(@javax.annotation.Nonnull String jobId, @javax.annotation.Nullable String xApiKey) throws ApiException {
        ApiResponse<ApiV1JobJobIdGet200Response> localVarResp = apiV1JobJobIdGetWithHttpInfo(jobId, xApiKey);
        return localVarResp.getData();
    }

    /**
     * Get task response
     * ## Retrieve Job Status and Results  Query the status and results of any task using its job ID. Use this to check progress, retrieve completed results, or diagnose failures.  ### How it Works  Provide a job ID from any previous API request. The API returns the current task status, progress information, and results (if completed). Poll this endpoint to track long-running tasks.  ### Required Parameters  - &#x60;job_id&#x60; - UUID of the task (passed in URL path)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns complete task information including:  - &#x60;status&#x60; - Current status: pending, staged, processing, failed, or completed      - &#x60;output&#x60; - Generated images/videos (null until completed)      - &#x60;meta&#x60; - Timestamps, usage information, processing details      - &#x60;error&#x60; - Error details if status is \&quot;failed\&quot;      - &#x60;logs&#x60; - Processing logs and progress updates       ### Status Values  - **pending**: Task queued, waiting to start      - **staged**: Task prepared, about to begin processing      - **processing**: Actively generating (includes progress percentage in logs)      - **completed**: Successfully finished, results available in output field      - **failed**: Processing failed, check error field for details       ### Use Cases  - Poll for task completion if not using webhooks      - Retrieve results for tasks completed days/weeks ago      - Debug failed tasks by examining error messages      - Monitor processing progress for long-running jobs      - Retrieve task history and usage information       ### Tips  - Job IDs are permanent - tasks can be retrieved anytime      - Poll every 10-30 seconds for pending tasks (avoid excessive polling)      - Webhook callbacks are more efficient than polling      - Failed tasks include detailed error messages for debugging      - Completed tasks retain all generation parameters in the input field
     * @param jobId  (required)
     * @param xApiKey  (optional)
     * @return ApiResponse&lt;ApiV1JobJobIdGet200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ApiV1JobJobIdGet200Response> apiV1JobJobIdGetWithHttpInfo(@javax.annotation.Nonnull String jobId, @javax.annotation.Nullable String xApiKey) throws ApiException {
        okhttp3.Call localVarCall = apiV1JobJobIdGetValidateBeforeCall(jobId, xApiKey, null);
        Type localVarReturnType = new TypeToken<ApiV1JobJobIdGet200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get task response (asynchronously)
     * ## Retrieve Job Status and Results  Query the status and results of any task using its job ID. Use this to check progress, retrieve completed results, or diagnose failures.  ### How it Works  Provide a job ID from any previous API request. The API returns the current task status, progress information, and results (if completed). Poll this endpoint to track long-running tasks.  ### Required Parameters  - &#x60;job_id&#x60; - UUID of the task (passed in URL path)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns complete task information including:  - &#x60;status&#x60; - Current status: pending, staged, processing, failed, or completed      - &#x60;output&#x60; - Generated images/videos (null until completed)      - &#x60;meta&#x60; - Timestamps, usage information, processing details      - &#x60;error&#x60; - Error details if status is \&quot;failed\&quot;      - &#x60;logs&#x60; - Processing logs and progress updates       ### Status Values  - **pending**: Task queued, waiting to start      - **staged**: Task prepared, about to begin processing      - **processing**: Actively generating (includes progress percentage in logs)      - **completed**: Successfully finished, results available in output field      - **failed**: Processing failed, check error field for details       ### Use Cases  - Poll for task completion if not using webhooks      - Retrieve results for tasks completed days/weeks ago      - Debug failed tasks by examining error messages      - Monitor processing progress for long-running jobs      - Retrieve task history and usage information       ### Tips  - Job IDs are permanent - tasks can be retrieved anytime      - Poll every 10-30 seconds for pending tasks (avoid excessive polling)      - Webhook callbacks are more efficient than polling      - Failed tasks include detailed error messages for debugging      - Completed tasks retain all generation parameters in the input field
     * @param jobId  (required)
     * @param xApiKey  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call apiV1JobJobIdGetAsync(@javax.annotation.Nonnull String jobId, @javax.annotation.Nullable String xApiKey, final ApiCallback<ApiV1JobJobIdGet200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = apiV1JobJobIdGetValidateBeforeCall(jobId, xApiKey, _callback);
        Type localVarReturnType = new TypeToken<ApiV1JobJobIdGet200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for apiV1VideoDiffusionPost
     * @param xApiKey  (optional)
     * @param body  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call apiV1VideoDiffusionPostCall(@javax.annotation.Nullable String xApiKey, @javax.annotation.Nullable Object body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/v1/video-diffusion";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (xApiKey != null) {
            localVarHeaderParams.put("x-api-key", localVarApiClient.parameterToString(xApiKey));
        }


        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call apiV1VideoDiffusionPostValidateBeforeCall(@javax.annotation.Nullable String xApiKey, @javax.annotation.Nullable Object body, final ApiCallback _callback) throws ApiException {
        return apiV1VideoDiffusionPostCall(xApiKey, body, _callback);

    }

    /**
     * Video Diffusion
     * ## Generate Videos from Text or Animate Images  Create dynamic videos either from text prompts or by animating existing generated images. Supports two modes: prompt-based generation and image-to-video animation.  ### How it Works  **Mode 1 - Text to Video**: Provide a text prompt and the API generates a video based on the description.   **Mode 2 - Image to Video**: Select a previously generated image and optionally add a prompt. The API animates the image, bringing it to life with motion.  Processing takes 3-5 minutes depending on quality settings. Videos are 4 seconds long.  ### Required Parameters  **For Text Mode**:  - &#x60;prompt&#x60; - Video generation prompt (1-8192 characters)      - &#x60;videoType&#x60; - Quality: 0&#x3D;480p (faster), 1&#x3D;720p (higher quality)       **For Image Animation Mode**:  - &#x60;jobId&#x60; - UUID of source image generation task      - &#x60;imageNo&#x60; - Image number to animate (0, 1, 2, or 3)      - &#x60;prompt&#x60; - Optional prompt to guide animation (1-8192 characters)      - &#x60;videoType&#x60; - Quality: 0&#x3D;480p (faster), 1&#x3D;720p (higher quality)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The generated videos (4 variations) will be sent to your callback URL when complete (typically 3-5 minutes).  ### Use Cases  - Create animated content from text descriptions      - Bring static generated images to life with animation      - Generate video content for social media      - Create motion graphics and animated sequences      - Produce video mockups and previews       ### Tips  - 720p quality takes longer but provides significantly better results      - Image animation mode adds motion to existing images      - 4-second duration is standard - use extend-video to lengthen      - Prompt in image mode guides animation style and movement      - Text mode generates both visual content and motion
     * @param xApiKey  (optional)
     * @param body  (optional)
     * @return TaskResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public TaskResponse apiV1VideoDiffusionPost(@javax.annotation.Nullable String xApiKey, @javax.annotation.Nullable Object body) throws ApiException {
        ApiResponse<TaskResponse> localVarResp = apiV1VideoDiffusionPostWithHttpInfo(xApiKey, body);
        return localVarResp.getData();
    }

    /**
     * Video Diffusion
     * ## Generate Videos from Text or Animate Images  Create dynamic videos either from text prompts or by animating existing generated images. Supports two modes: prompt-based generation and image-to-video animation.  ### How it Works  **Mode 1 - Text to Video**: Provide a text prompt and the API generates a video based on the description.   **Mode 2 - Image to Video**: Select a previously generated image and optionally add a prompt. The API animates the image, bringing it to life with motion.  Processing takes 3-5 minutes depending on quality settings. Videos are 4 seconds long.  ### Required Parameters  **For Text Mode**:  - &#x60;prompt&#x60; - Video generation prompt (1-8192 characters)      - &#x60;videoType&#x60; - Quality: 0&#x3D;480p (faster), 1&#x3D;720p (higher quality)       **For Image Animation Mode**:  - &#x60;jobId&#x60; - UUID of source image generation task      - &#x60;imageNo&#x60; - Image number to animate (0, 1, 2, or 3)      - &#x60;prompt&#x60; - Optional prompt to guide animation (1-8192 characters)      - &#x60;videoType&#x60; - Quality: 0&#x3D;480p (faster), 1&#x3D;720p (higher quality)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The generated videos (4 variations) will be sent to your callback URL when complete (typically 3-5 minutes).  ### Use Cases  - Create animated content from text descriptions      - Bring static generated images to life with animation      - Generate video content for social media      - Create motion graphics and animated sequences      - Produce video mockups and previews       ### Tips  - 720p quality takes longer but provides significantly better results      - Image animation mode adds motion to existing images      - 4-second duration is standard - use extend-video to lengthen      - Prompt in image mode guides animation style and movement      - Text mode generates both visual content and motion
     * @param xApiKey  (optional)
     * @param body  (optional)
     * @return ApiResponse&lt;TaskResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TaskResponse> apiV1VideoDiffusionPostWithHttpInfo(@javax.annotation.Nullable String xApiKey, @javax.annotation.Nullable Object body) throws ApiException {
        okhttp3.Call localVarCall = apiV1VideoDiffusionPostValidateBeforeCall(xApiKey, body, null);
        Type localVarReturnType = new TypeToken<TaskResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Video Diffusion (asynchronously)
     * ## Generate Videos from Text or Animate Images  Create dynamic videos either from text prompts or by animating existing generated images. Supports two modes: prompt-based generation and image-to-video animation.  ### How it Works  **Mode 1 - Text to Video**: Provide a text prompt and the API generates a video based on the description.   **Mode 2 - Image to Video**: Select a previously generated image and optionally add a prompt. The API animates the image, bringing it to life with motion.  Processing takes 3-5 minutes depending on quality settings. Videos are 4 seconds long.  ### Required Parameters  **For Text Mode**:  - &#x60;prompt&#x60; - Video generation prompt (1-8192 characters)      - &#x60;videoType&#x60; - Quality: 0&#x3D;480p (faster), 1&#x3D;720p (higher quality)       **For Image Animation Mode**:  - &#x60;jobId&#x60; - UUID of source image generation task      - &#x60;imageNo&#x60; - Image number to animate (0, 1, 2, or 3)      - &#x60;prompt&#x60; - Optional prompt to guide animation (1-8192 characters)      - &#x60;videoType&#x60; - Quality: 0&#x3D;480p (faster), 1&#x3D;720p (higher quality)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The generated videos (4 variations) will be sent to your callback URL when complete (typically 3-5 minutes).  ### Use Cases  - Create animated content from text descriptions      - Bring static generated images to life with animation      - Generate video content for social media      - Create motion graphics and animated sequences      - Produce video mockups and previews       ### Tips  - 720p quality takes longer but provides significantly better results      - Image animation mode adds motion to existing images      - 4-second duration is standard - use extend-video to lengthen      - Prompt in image mode guides animation style and movement      - Text mode generates both visual content and motion
     * @param xApiKey  (optional)
     * @param body  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call apiV1VideoDiffusionPostAsync(@javax.annotation.Nullable String xApiKey, @javax.annotation.Nullable Object body, final ApiCallback<TaskResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = apiV1VideoDiffusionPostValidateBeforeCall(xApiKey, body, _callback);
        Type localVarReturnType = new TypeToken<TaskResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for apiV1VideoUpscalePost
     * @param xApiKey  (optional)
     * @param body  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call apiV1VideoUpscalePostCall(@javax.annotation.Nullable String xApiKey, @javax.annotation.Nullable Object body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/api/v1/video-upscale";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (xApiKey != null) {
            localVarHeaderParams.put("x-api-key", localVarApiClient.parameterToString(xApiKey));
        }


        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call apiV1VideoUpscalePostValidateBeforeCall(@javax.annotation.Nullable String xApiKey, @javax.annotation.Nullable Object body, final ApiCallback _callback) throws ApiException {
        return apiV1VideoUpscalePostCall(xApiKey, body, _callback);

    }

    /**
     * Video Upscale
     * ## Enhance Video Resolution and Quality  Upscale generated videos to higher resolution with AI-powered quality enhancement. Improves clarity, detail, and overall visual quality.  ### How it Works  Select a previously generated video and the API processes each frame to increase resolution and enhance quality while maintaining motion smoothness and temporal consistency.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original video generation task      - &#x60;videoNo&#x60; - Video number to upscale (0, 1, 2, or 3)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The upscaled video will be sent to your callback URL when complete (typically 4-6 minutes).  ### Use Cases  - Prepare videos for high-resolution displays      - Enhance quality of draft-quality generations      - Create production-ready video assets      - Improve detail and clarity for professional use      - Upgrade videos for client presentations       ### Tips  - Significantly increases processing time due to frame-by-frame enhancement      - Best applied after you&#39;ve selected your preferred video variation      - Cannot be reversed - always keep original lower-resolution version      - Quality improvement is substantial for text clarity and fine details      - Consider workflow: generate/extend first, upscale final selection
     * @param xApiKey  (optional)
     * @param body  (optional)
     * @return TaskResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public TaskResponse apiV1VideoUpscalePost(@javax.annotation.Nullable String xApiKey, @javax.annotation.Nullable Object body) throws ApiException {
        ApiResponse<TaskResponse> localVarResp = apiV1VideoUpscalePostWithHttpInfo(xApiKey, body);
        return localVarResp.getData();
    }

    /**
     * Video Upscale
     * ## Enhance Video Resolution and Quality  Upscale generated videos to higher resolution with AI-powered quality enhancement. Improves clarity, detail, and overall visual quality.  ### How it Works  Select a previously generated video and the API processes each frame to increase resolution and enhance quality while maintaining motion smoothness and temporal consistency.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original video generation task      - &#x60;videoNo&#x60; - Video number to upscale (0, 1, 2, or 3)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The upscaled video will be sent to your callback URL when complete (typically 4-6 minutes).  ### Use Cases  - Prepare videos for high-resolution displays      - Enhance quality of draft-quality generations      - Create production-ready video assets      - Improve detail and clarity for professional use      - Upgrade videos for client presentations       ### Tips  - Significantly increases processing time due to frame-by-frame enhancement      - Best applied after you&#39;ve selected your preferred video variation      - Cannot be reversed - always keep original lower-resolution version      - Quality improvement is substantial for text clarity and fine details      - Consider workflow: generate/extend first, upscale final selection
     * @param xApiKey  (optional)
     * @param body  (optional)
     * @return ApiResponse&lt;TaskResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TaskResponse> apiV1VideoUpscalePostWithHttpInfo(@javax.annotation.Nullable String xApiKey, @javax.annotation.Nullable Object body) throws ApiException {
        okhttp3.Call localVarCall = apiV1VideoUpscalePostValidateBeforeCall(xApiKey, body, null);
        Type localVarReturnType = new TypeToken<TaskResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Video Upscale (asynchronously)
     * ## Enhance Video Resolution and Quality  Upscale generated videos to higher resolution with AI-powered quality enhancement. Improves clarity, detail, and overall visual quality.  ### How it Works  Select a previously generated video and the API processes each frame to increase resolution and enhance quality while maintaining motion smoothness and temporal consistency.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original video generation task      - &#x60;videoNo&#x60; - Video number to upscale (0, 1, 2, or 3)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The upscaled video will be sent to your callback URL when complete (typically 4-6 minutes).  ### Use Cases  - Prepare videos for high-resolution displays      - Enhance quality of draft-quality generations      - Create production-ready video assets      - Improve detail and clarity for professional use      - Upgrade videos for client presentations       ### Tips  - Significantly increases processing time due to frame-by-frame enhancement      - Best applied after you&#39;ve selected your preferred video variation      - Cannot be reversed - always keep original lower-resolution version      - Quality improvement is substantial for text clarity and fine details      - Consider workflow: generate/extend first, upscale final selection
     * @param xApiKey  (optional)
     * @param body  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful response </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call apiV1VideoUpscalePostAsync(@javax.annotation.Nullable String xApiKey, @javax.annotation.Nullable Object body, final ApiCallback<TaskResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = apiV1VideoUpscalePostValidateBeforeCall(xApiKey, body, _callback);
        Type localVarReturnType = new TypeToken<TaskResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
