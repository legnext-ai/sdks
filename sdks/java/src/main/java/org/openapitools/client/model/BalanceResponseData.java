/*
 * Midjourney api-unofficial by Legnext.ai
 * # **Legnext.ai Midjourney API: The Ultimate AI Image Generation Toolkit**  Unlock the full creative potential of Midjourney directly within your applications and development workflows using the **Legnext.ai Midjourney API (Unofficial)**. This comprehensive collection offers a ready-to-integrate solution for professional image and video creation, manipulation, and high-fidelity upscaling.  We provide developers with **stable, high-performance API access** to the Midjourney model. Crucially, integrating our service requires **no Midjourney account**, eliminating the hassle of managing official subscriptions or Discord interactions. Our toolkit simplifies the entire text-to-image process, supporting complex prompts, aspect ratio adjustments, and advanced style parameters.  Focus on innovation while we handle the AI infrastructure. Start building scalable, visually stunning applications today with reliable access to the worldâ€™s leading generative AI model.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * BalanceResponseData
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2026-01-13T18:54:28.851432016+08:00[Asia/Shanghai]", comments = "Generator version: 7.18.0")
public class BalanceResponseData {
  public static final String SERIALIZED_NAME_ACCOUNT_ID = "account_id";
  @SerializedName(SERIALIZED_NAME_ACCOUNT_ID)
  @javax.annotation.Nullable
  private Integer accountId;

  public static final String SERIALIZED_NAME_BALANCE_USD = "balance_usd";
  @SerializedName(SERIALIZED_NAME_BALANCE_USD)
  @javax.annotation.Nullable
  private Float balanceUsd;

  public static final String SERIALIZED_NAME_AVAILABLE_CREDITS = "available_credits";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_CREDITS)
  @javax.annotation.Nullable
  private Integer availableCredits;

  public static final String SERIALIZED_NAME_AVAILABLE_POINTS = "available_points";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_POINTS)
  @javax.annotation.Nullable
  private Integer availablePoints;

  public static final String SERIALIZED_NAME_ALERT_THRESHOLD = "alert_threshold";
  @SerializedName(SERIALIZED_NAME_ALERT_THRESHOLD)
  @javax.annotation.Nullable
  private Integer alertThreshold;

  public static final String SERIALIZED_NAME_LOW_BALANCE_ALERT = "low_balance_alert";
  @SerializedName(SERIALIZED_NAME_LOW_BALANCE_ALERT)
  @javax.annotation.Nullable
  private Boolean lowBalanceAlert;

  public static final String SERIALIZED_NAME_UPDATED_AT = "updated_at";
  @SerializedName(SERIALIZED_NAME_UPDATED_AT)
  @javax.annotation.Nullable
  private OffsetDateTime updatedAt;

  public BalanceResponseData() {
  }

  public BalanceResponseData accountId(@javax.annotation.Nullable Integer accountId) {
    this.accountId = accountId;
    return this;
  }

  /**
   * Account identifier
   * @return accountId
   */
  @javax.annotation.Nullable
  public Integer getAccountId() {
    return accountId;
  }

  public void setAccountId(@javax.annotation.Nullable Integer accountId) {
    this.accountId = accountId;
  }


  public BalanceResponseData balanceUsd(@javax.annotation.Nullable Float balanceUsd) {
    this.balanceUsd = balanceUsd;
    return this;
  }

  /**
   * Current balance in USD
   * @return balanceUsd
   */
  @javax.annotation.Nullable
  public Float getBalanceUsd() {
    return balanceUsd;
  }

  public void setBalanceUsd(@javax.annotation.Nullable Float balanceUsd) {
    this.balanceUsd = balanceUsd;
  }


  public BalanceResponseData availableCredits(@javax.annotation.Nullable Integer availableCredits) {
    this.availableCredits = availableCredits;
    return this;
  }

  /**
   * Available credits for API usage
   * @return availableCredits
   */
  @javax.annotation.Nullable
  public Integer getAvailableCredits() {
    return availableCredits;
  }

  public void setAvailableCredits(@javax.annotation.Nullable Integer availableCredits) {
    this.availableCredits = availableCredits;
  }


  public BalanceResponseData availablePoints(@javax.annotation.Nullable Integer availablePoints) {
    this.availablePoints = availablePoints;
    return this;
  }

  /**
   * Available points
   * @return availablePoints
   */
  @javax.annotation.Nullable
  public Integer getAvailablePoints() {
    return availablePoints;
  }

  public void setAvailablePoints(@javax.annotation.Nullable Integer availablePoints) {
    this.availablePoints = availablePoints;
  }


  public BalanceResponseData alertThreshold(@javax.annotation.Nullable Integer alertThreshold) {
    this.alertThreshold = alertThreshold;
    return this;
  }

  /**
   * Low balance alert threshold in USD
   * @return alertThreshold
   */
  @javax.annotation.Nullable
  public Integer getAlertThreshold() {
    return alertThreshold;
  }

  public void setAlertThreshold(@javax.annotation.Nullable Integer alertThreshold) {
    this.alertThreshold = alertThreshold;
  }


  public BalanceResponseData lowBalanceAlert(@javax.annotation.Nullable Boolean lowBalanceAlert) {
    this.lowBalanceAlert = lowBalanceAlert;
    return this;
  }

  /**
   * Whether low balance alert is triggered
   * @return lowBalanceAlert
   */
  @javax.annotation.Nullable
  public Boolean getLowBalanceAlert() {
    return lowBalanceAlert;
  }

  public void setLowBalanceAlert(@javax.annotation.Nullable Boolean lowBalanceAlert) {
    this.lowBalanceAlert = lowBalanceAlert;
  }


  public BalanceResponseData updatedAt(@javax.annotation.Nullable OffsetDateTime updatedAt) {
    this.updatedAt = updatedAt;
    return this;
  }

  /**
   * Last update timestamp
   * @return updatedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getUpdatedAt() {
    return updatedAt;
  }

  public void setUpdatedAt(@javax.annotation.Nullable OffsetDateTime updatedAt) {
    this.updatedAt = updatedAt;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BalanceResponseData balanceResponseData = (BalanceResponseData) o;
    return Objects.equals(this.accountId, balanceResponseData.accountId) &&
        Objects.equals(this.balanceUsd, balanceResponseData.balanceUsd) &&
        Objects.equals(this.availableCredits, balanceResponseData.availableCredits) &&
        Objects.equals(this.availablePoints, balanceResponseData.availablePoints) &&
        Objects.equals(this.alertThreshold, balanceResponseData.alertThreshold) &&
        Objects.equals(this.lowBalanceAlert, balanceResponseData.lowBalanceAlert) &&
        Objects.equals(this.updatedAt, balanceResponseData.updatedAt);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accountId, balanceUsd, availableCredits, availablePoints, alertThreshold, lowBalanceAlert, updatedAt);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BalanceResponseData {\n");
    sb.append("    accountId: ").append(toIndentedString(accountId)).append("\n");
    sb.append("    balanceUsd: ").append(toIndentedString(balanceUsd)).append("\n");
    sb.append("    availableCredits: ").append(toIndentedString(availableCredits)).append("\n");
    sb.append("    availablePoints: ").append(toIndentedString(availablePoints)).append("\n");
    sb.append("    alertThreshold: ").append(toIndentedString(alertThreshold)).append("\n");
    sb.append("    lowBalanceAlert: ").append(toIndentedString(lowBalanceAlert)).append("\n");
    sb.append("    updatedAt: ").append(toIndentedString(updatedAt)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>(Arrays.asList("account_id", "balance_usd", "available_credits", "available_points", "alert_threshold", "low_balance_alert", "updated_at"));

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>(0);
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to BalanceResponseData
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!BalanceResponseData.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format(java.util.Locale.ROOT, "The required field(s) %s in BalanceResponseData is not found in the empty JSON string", BalanceResponseData.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!BalanceResponseData.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format(java.util.Locale.ROOT, "The field `%s` in the JSON string is not defined in the `BalanceResponseData` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!BalanceResponseData.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'BalanceResponseData' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<BalanceResponseData> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(BalanceResponseData.class));

       return (TypeAdapter<T>) new TypeAdapter<BalanceResponseData>() {
           @Override
           public void write(JsonWriter out, BalanceResponseData value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public BalanceResponseData read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of BalanceResponseData given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of BalanceResponseData
   * @throws IOException if the JSON string is invalid with respect to BalanceResponseData
   */
  public static BalanceResponseData fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, BalanceResponseData.class);
  }

  /**
   * Convert an instance of BalanceResponseData to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

