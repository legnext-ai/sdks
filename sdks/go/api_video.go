/*
Midjourney api-unofficial by Legnext.ai

# **Legnext.ai Midjourney API: The Ultimate AI Image Generation Toolkit**  Unlock the full creative potential of Midjourney directly within your applications and development workflows using the **Legnext.ai Midjourney API (Unofficial)**. This comprehensive collection offers a ready-to-integrate solution for professional image and video creation, manipulation, and high-fidelity upscaling.  We provide developers with **stable, high-performance API access** to the Midjourney model. Crucially, integrating our service requires **no Midjourney account**, eliminating the hassle of managing official subscriptions or Discord interactions. Our toolkit simplifies the entire text-to-image process, supporting complex prompts, aspect ratio adjustments, and advanced style parameters.  Focus on innovation while we handle the AI infrastructure. Start building scalable, visually stunning applications today with reliable access to the worldâ€™s leading generative AI model.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// VideoAPIService VideoAPI service
type VideoAPIService service

type ApiApiV1ExtendVideoPostRequest struct {
	ctx context.Context
	ApiService *VideoAPIService
	xApiKey *string
	body *map[string]interface{}
}

func (r ApiApiV1ExtendVideoPostRequest) XApiKey(xApiKey string) ApiApiV1ExtendVideoPostRequest {
	r.xApiKey = &xApiKey
	return r
}

func (r ApiApiV1ExtendVideoPostRequest) Body(body map[string]interface{}) ApiApiV1ExtendVideoPostRequest {
	r.body = &body
	return r
}

func (r ApiApiV1ExtendVideoPostRequest) Execute() (*TaskResponse, *http.Response, error) {
	return r.ApiService.ApiV1ExtendVideoPostExecute(r)
}

/*
ApiV1ExtendVideoPost Extend Video

## Extend Video Duration with Seamless Continuation

Add additional frames to extend the duration of generated videos. Creates smooth continuations that seamlessly flow from the original video.

### How it Works

Select a previously generated video and optionally provide a prompt to guide the extension. The API analyzes the video's motion and content, then generates additional frames that naturally continue the sequence. Each extension adds 4 seconds.

### Required Parameters

- `jobId` - UUID of the original video generation task
    
- `videoNo` - Video number to extend (0, 1, 2, or 3)
    
- `prompt` - Optional prompt to guide the extension (1-8192 characters)
    

### Authentication

Requires a valid API key passed in the `x-api-key` header.

### Response

Returns a task object. The extended video will be sent to your callback URL when complete (typically 3-5 minutes).

### Use Cases

- Create longer videos from initial 4-second generations
    
- Extend successful animations for more content
    
- Build sequential video narratives
    
- Generate longer social media content
    
- Create extended motion sequences
    

### Tips

- Each extension adds 4 seconds to the video
    
- Can extend up to 4 times (maximum 20 seconds total: 4+4+4+4+4)
    
- Prompt helps guide what happens in the extended portion
    
- Extension quality depends on the source video's clarity and motion
    
- Works with both text-generated and image-animated videos

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV1ExtendVideoPostRequest
*/
func (a *VideoAPIService) ApiV1ExtendVideoPost(ctx context.Context) ApiApiV1ExtendVideoPostRequest {
	return ApiApiV1ExtendVideoPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TaskResponse
func (a *VideoAPIService) ApiV1ExtendVideoPostExecute(r ApiApiV1ExtendVideoPostRequest) (*TaskResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VideoAPIService.ApiV1ExtendVideoPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/extend-video"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-key", r.xApiKey, "simple", "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV1JobJobIdGetRequest struct {
	ctx context.Context
	ApiService *VideoAPIService
	jobId string
	xApiKey *string
}

func (r ApiApiV1JobJobIdGetRequest) XApiKey(xApiKey string) ApiApiV1JobJobIdGetRequest {
	r.xApiKey = &xApiKey
	return r
}

func (r ApiApiV1JobJobIdGetRequest) Execute() (*ApiV1JobJobIdGet200Response, *http.Response, error) {
	return r.ApiService.ApiV1JobJobIdGetExecute(r)
}

/*
ApiV1JobJobIdGet Get task response

## Retrieve Job Status and Results

Query the status and results of any task using its job ID. Use this to check progress, retrieve completed results, or diagnose failures.

### How it Works

Provide a job ID from any previous API request. The API returns the current task status, progress information, and results (if completed). Poll this endpoint to track long-running tasks.

### Required Parameters

- `job_id` - UUID of the task (passed in URL path)
    

### Authentication

Requires a valid API key passed in the `x-api-key` header.

### Response

Returns complete task information including:

- `status` - Current status: pending, staged, processing, failed, or completed
    
- `output` - Generated images/videos (null until completed)
    
- `meta` - Timestamps, usage information, processing details
    
- `error` - Error details if status is "failed"
    
- `logs` - Processing logs and progress updates
    

### Status Values

- **pending**: Task queued, waiting to start
    
- **staged**: Task prepared, about to begin processing
    
- **processing**: Actively generating (includes progress percentage in logs)
    
- **completed**: Successfully finished, results available in output field
    
- **failed**: Processing failed, check error field for details
    

### Use Cases

- Poll for task completion if not using webhooks
    
- Retrieve results for tasks completed days/weeks ago
    
- Debug failed tasks by examining error messages
    
- Monitor processing progress for long-running jobs
    
- Retrieve task history and usage information
    

### Tips

- Job IDs are permanent - tasks can be retrieved anytime
    
- Poll every 10-30 seconds for pending tasks (avoid excessive polling)
    
- Webhook callbacks are more efficient than polling
    
- Failed tasks include detailed error messages for debugging
    
- Completed tasks retain all generation parameters in the input field

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId
 @return ApiApiV1JobJobIdGetRequest
*/
func (a *VideoAPIService) ApiV1JobJobIdGet(ctx context.Context, jobId string) ApiApiV1JobJobIdGetRequest {
	return ApiApiV1JobJobIdGetRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return ApiV1JobJobIdGet200Response
func (a *VideoAPIService) ApiV1JobJobIdGetExecute(r ApiApiV1JobJobIdGetRequest) (*ApiV1JobJobIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiV1JobJobIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VideoAPIService.ApiV1JobJobIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/job/{job_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-key", r.xApiKey, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV1VideoDiffusionPostRequest struct {
	ctx context.Context
	ApiService *VideoAPIService
	xApiKey *string
	body *map[string]interface{}
}

func (r ApiApiV1VideoDiffusionPostRequest) XApiKey(xApiKey string) ApiApiV1VideoDiffusionPostRequest {
	r.xApiKey = &xApiKey
	return r
}

func (r ApiApiV1VideoDiffusionPostRequest) Body(body map[string]interface{}) ApiApiV1VideoDiffusionPostRequest {
	r.body = &body
	return r
}

func (r ApiApiV1VideoDiffusionPostRequest) Execute() (*TaskResponse, *http.Response, error) {
	return r.ApiService.ApiV1VideoDiffusionPostExecute(r)
}

/*
ApiV1VideoDiffusionPost Video Diffusion

## Generate Videos from Text or Animate Images

Create dynamic videos either from text prompts or by animating existing generated images. Supports two modes: prompt-based generation and image-to-video animation.

### How it Works

**Mode 1 - Text to Video**: Provide a text prompt and the API generates a video based on the description.  
**Mode 2 - Image to Video**: Select a previously generated image and optionally add a prompt. The API animates the image, bringing it to life with motion.

Processing takes 3-5 minutes depending on quality settings. Videos are 4 seconds long.

### Required Parameters

**For Text Mode**:

- `prompt` - Video generation prompt (1-8192 characters)
    
- `videoType` - Quality: 0=480p (faster), 1=720p (higher quality)
    

**For Image Animation Mode**:

- `jobId` - UUID of source image generation task
    
- `imageNo` - Image number to animate (0, 1, 2, or 3)
    
- `prompt` - Optional prompt to guide animation (1-8192 characters)
    
- `videoType` - Quality: 0=480p (faster), 1=720p (higher quality)
    

### Authentication

Requires a valid API key passed in the `x-api-key` header.

### Response

Returns a task object. The generated videos (4 variations) will be sent to your callback URL when complete (typically 3-5 minutes).

### Use Cases

- Create animated content from text descriptions
    
- Bring static generated images to life with animation
    
- Generate video content for social media
    
- Create motion graphics and animated sequences
    
- Produce video mockups and previews
    

### Tips

- 720p quality takes longer but provides significantly better results
    
- Image animation mode adds motion to existing images
    
- 4-second duration is standard - use extend-video to lengthen
    
- Prompt in image mode guides animation style and movement
    
- Text mode generates both visual content and motion

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV1VideoDiffusionPostRequest
*/
func (a *VideoAPIService) ApiV1VideoDiffusionPost(ctx context.Context) ApiApiV1VideoDiffusionPostRequest {
	return ApiApiV1VideoDiffusionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TaskResponse
func (a *VideoAPIService) ApiV1VideoDiffusionPostExecute(r ApiApiV1VideoDiffusionPostRequest) (*TaskResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VideoAPIService.ApiV1VideoDiffusionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/video-diffusion"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-key", r.xApiKey, "simple", "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV1VideoUpscalePostRequest struct {
	ctx context.Context
	ApiService *VideoAPIService
	xApiKey *string
	body *map[string]interface{}
}

func (r ApiApiV1VideoUpscalePostRequest) XApiKey(xApiKey string) ApiApiV1VideoUpscalePostRequest {
	r.xApiKey = &xApiKey
	return r
}

func (r ApiApiV1VideoUpscalePostRequest) Body(body map[string]interface{}) ApiApiV1VideoUpscalePostRequest {
	r.body = &body
	return r
}

func (r ApiApiV1VideoUpscalePostRequest) Execute() (*TaskResponse, *http.Response, error) {
	return r.ApiService.ApiV1VideoUpscalePostExecute(r)
}

/*
ApiV1VideoUpscalePost Video Upscale

## Enhance Video Resolution and Quality

Upscale generated videos to higher resolution with AI-powered quality enhancement. Improves clarity, detail, and overall visual quality.

### How it Works

Select a previously generated video and the API processes each frame to increase resolution and enhance quality while maintaining motion smoothness and temporal consistency.

### Required Parameters

- `jobId` - UUID of the original video generation task
    
- `videoNo` - Video number to upscale (0, 1, 2, or 3)
    

### Authentication

Requires a valid API key passed in the `x-api-key` header.

### Response

Returns a task object. The upscaled video will be sent to your callback URL when complete (typically 4-6 minutes).

### Use Cases

- Prepare videos for high-resolution displays
    
- Enhance quality of draft-quality generations
    
- Create production-ready video assets
    
- Improve detail and clarity for professional use
    
- Upgrade videos for client presentations
    

### Tips

- Significantly increases processing time due to frame-by-frame enhancement
    
- Best applied after you've selected your preferred video variation
    
- Cannot be reversed - always keep original lower-resolution version
    
- Quality improvement is substantial for text clarity and fine details
    
- Consider workflow: generate/extend first, upscale final selection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV1VideoUpscalePostRequest
*/
func (a *VideoAPIService) ApiV1VideoUpscalePost(ctx context.Context) ApiApiV1VideoUpscalePostRequest {
	return ApiApiV1VideoUpscalePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TaskResponse
func (a *VideoAPIService) ApiV1VideoUpscalePostExecute(r ApiApiV1VideoUpscalePostRequest) (*TaskResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VideoAPIService.ApiV1VideoUpscalePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/video-upscale"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApiKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-key", r.xApiKey, "simple", "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
