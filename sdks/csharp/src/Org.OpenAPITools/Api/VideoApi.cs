// <auto-generated>
/*
 * Midjourney api-unofficial by Legnext.ai
 *
 * # **Legnext.ai Midjourney API: The Ultimate AI Image Generation Toolkit**  Unlock the full creative potential of Midjourney directly within your applications and development workflows using the **Legnext.ai Midjourney API (Unofficial)**. This comprehensive collection offers a ready-to-integrate solution for professional image and video creation, manipulation, and high-fidelity upscaling.  We provide developers with **stable, high-performance API access** to the Midjourney model. Crucially, integrating our service requires **no Midjourney account**, eliminating the hassle of managing official subscriptions or Discord interactions. Our toolkit simplifies the entire text-to-image process, supporting complex prompts, aspect ratio adjustments, and advanced style parameters.  Focus on innovation while we handle the AI infrastructure. Start building scalable, visually stunning applications today with reliable access to the worldâ€™s leading generative AI model.
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Org.OpenAPITools.Client;
using Org.OpenAPITools.Model;
using System.Diagnostics.CodeAnalysis;

namespace Org.OpenAPITools.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IVideoApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        VideoApiEvents Events { get; }

        /// <summary>
        /// Extend Video
        /// </summary>
        /// <remarks>
        /// ## Extend Video Duration with Seamless Continuation  Add additional frames to extend the duration of generated videos. Creates smooth continuations that seamlessly flow from the original video.  ### How it Works  Select a previously generated video and optionally provide a prompt to guide the extension. The API analyzes the video&#39;s motion and content, then generates additional frames that naturally continue the sequence. Each extension adds 4 seconds.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original video generation task      - &#x60;videoNo&#x60; - Video number to extend (0, 1, 2, or 3)      - &#x60;prompt&#x60; - Optional prompt to guide the extension (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The extended video will be sent to your callback URL when complete (typically 3-5 minutes).  ### Use Cases  - Create longer videos from initial 4-second generations      - Extend successful animations for more content      - Build sequential video narratives      - Generate longer social media content      - Create extended motion sequences       ### Tips  - Each extension adds 4 seconds to the video      - Can extend up to 4 times (maximum 20 seconds total: 4+4+4+4+4)      - Prompt helps guide what happens in the extended portion      - Extension quality depends on the source video&#39;s clarity and motion      - Works with both text-generated and image-animated videos
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1ExtendVideoPostApiResponse"/>&gt;</returns>
        Task<IApiV1ExtendVideoPostApiResponse> ApiV1ExtendVideoPostAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Extend Video
        /// </summary>
        /// <remarks>
        /// ## Extend Video Duration with Seamless Continuation  Add additional frames to extend the duration of generated videos. Creates smooth continuations that seamlessly flow from the original video.  ### How it Works  Select a previously generated video and optionally provide a prompt to guide the extension. The API analyzes the video&#39;s motion and content, then generates additional frames that naturally continue the sequence. Each extension adds 4 seconds.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original video generation task      - &#x60;videoNo&#x60; - Video number to extend (0, 1, 2, or 3)      - &#x60;prompt&#x60; - Optional prompt to guide the extension (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The extended video will be sent to your callback URL when complete (typically 3-5 minutes).  ### Use Cases  - Create longer videos from initial 4-second generations      - Extend successful animations for more content      - Build sequential video narratives      - Generate longer social media content      - Create extended motion sequences       ### Tips  - Each extension adds 4 seconds to the video      - Can extend up to 4 times (maximum 20 seconds total: 4+4+4+4+4)      - Prompt helps guide what happens in the extended portion      - Extension quality depends on the source video&#39;s clarity and motion      - Works with both text-generated and image-animated videos
        /// </remarks>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1ExtendVideoPostApiResponse"/>?&gt;</returns>
        Task<IApiV1ExtendVideoPostApiResponse?> ApiV1ExtendVideoPostOrDefaultAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get task response
        /// </summary>
        /// <remarks>
        /// ## Retrieve Job Status and Results  Query the status and results of any task using its job ID. Use this to check progress, retrieve completed results, or diagnose failures.  ### How it Works  Provide a job ID from any previous API request. The API returns the current task status, progress information, and results (if completed). Poll this endpoint to track long-running tasks.  ### Required Parameters  - &#x60;job_id&#x60; - UUID of the task (passed in URL path)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns complete task information including:  - &#x60;status&#x60; - Current status: pending, staged, processing, failed, or completed      - &#x60;output&#x60; - Generated images/videos (null until completed)      - &#x60;meta&#x60; - Timestamps, usage information, processing details      - &#x60;error&#x60; - Error details if status is \&quot;failed\&quot;      - &#x60;logs&#x60; - Processing logs and progress updates       ### Status Values  - **pending**: Task queued, waiting to start      - **staged**: Task prepared, about to begin processing      - **processing**: Actively generating (includes progress percentage in logs)      - **completed**: Successfully finished, results available in output field      - **failed**: Processing failed, check error field for details       ### Use Cases  - Poll for task completion if not using webhooks      - Retrieve results for tasks completed days/weeks ago      - Debug failed tasks by examining error messages      - Monitor processing progress for long-running jobs      - Retrieve task history and usage information       ### Tips  - Job IDs are permanent - tasks can be retrieved anytime      - Poll every 10-30 seconds for pending tasks (avoid excessive polling)      - Webhook callbacks are more efficient than polling      - Failed tasks include detailed error messages for debugging      - Completed tasks retain all generation parameters in the input field
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="jobId"></param>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1JobJobIdGetApiResponse"/>&gt;</returns>
        Task<IApiV1JobJobIdGetApiResponse> ApiV1JobJobIdGetAsync(string jobId, Option<string> xApiKey = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get task response
        /// </summary>
        /// <remarks>
        /// ## Retrieve Job Status and Results  Query the status and results of any task using its job ID. Use this to check progress, retrieve completed results, or diagnose failures.  ### How it Works  Provide a job ID from any previous API request. The API returns the current task status, progress information, and results (if completed). Poll this endpoint to track long-running tasks.  ### Required Parameters  - &#x60;job_id&#x60; - UUID of the task (passed in URL path)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns complete task information including:  - &#x60;status&#x60; - Current status: pending, staged, processing, failed, or completed      - &#x60;output&#x60; - Generated images/videos (null until completed)      - &#x60;meta&#x60; - Timestamps, usage information, processing details      - &#x60;error&#x60; - Error details if status is \&quot;failed\&quot;      - &#x60;logs&#x60; - Processing logs and progress updates       ### Status Values  - **pending**: Task queued, waiting to start      - **staged**: Task prepared, about to begin processing      - **processing**: Actively generating (includes progress percentage in logs)      - **completed**: Successfully finished, results available in output field      - **failed**: Processing failed, check error field for details       ### Use Cases  - Poll for task completion if not using webhooks      - Retrieve results for tasks completed days/weeks ago      - Debug failed tasks by examining error messages      - Monitor processing progress for long-running jobs      - Retrieve task history and usage information       ### Tips  - Job IDs are permanent - tasks can be retrieved anytime      - Poll every 10-30 seconds for pending tasks (avoid excessive polling)      - Webhook callbacks are more efficient than polling      - Failed tasks include detailed error messages for debugging      - Completed tasks retain all generation parameters in the input field
        /// </remarks>
        /// <param name="jobId"></param>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1JobJobIdGetApiResponse"/>?&gt;</returns>
        Task<IApiV1JobJobIdGetApiResponse?> ApiV1JobJobIdGetOrDefaultAsync(string jobId, Option<string> xApiKey = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Video Diffusion
        /// </summary>
        /// <remarks>
        /// ## Generate Videos from Text or Animate Images  Create dynamic videos either from text prompts or by animating existing generated images. Supports two modes: prompt-based generation and image-to-video animation.  ### How it Works  **Mode 1 - Text to Video**: Provide a text prompt and the API generates a video based on the description.   **Mode 2 - Image to Video**: Select a previously generated image and optionally add a prompt. The API animates the image, bringing it to life with motion.  Processing takes 3-5 minutes depending on quality settings. Videos are 4 seconds long.  ### Required Parameters  **For Text Mode**:  - &#x60;prompt&#x60; - Video generation prompt (1-8192 characters)      - &#x60;videoType&#x60; - Quality: 0&#x3D;480p (faster), 1&#x3D;720p (higher quality)       **For Image Animation Mode**:  - &#x60;jobId&#x60; - UUID of source image generation task      - &#x60;imageNo&#x60; - Image number to animate (0, 1, 2, or 3)      - &#x60;prompt&#x60; - Optional prompt to guide animation (1-8192 characters)      - &#x60;videoType&#x60; - Quality: 0&#x3D;480p (faster), 1&#x3D;720p (higher quality)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The generated videos (4 variations) will be sent to your callback URL when complete (typically 3-5 minutes).  ### Use Cases  - Create animated content from text descriptions      - Bring static generated images to life with animation      - Generate video content for social media      - Create motion graphics and animated sequences      - Produce video mockups and previews       ### Tips  - 720p quality takes longer but provides significantly better results      - Image animation mode adds motion to existing images      - 4-second duration is standard - use extend-video to lengthen      - Prompt in image mode guides animation style and movement      - Text mode generates both visual content and motion
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1VideoDiffusionPostApiResponse"/>&gt;</returns>
        Task<IApiV1VideoDiffusionPostApiResponse> ApiV1VideoDiffusionPostAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Video Diffusion
        /// </summary>
        /// <remarks>
        /// ## Generate Videos from Text or Animate Images  Create dynamic videos either from text prompts or by animating existing generated images. Supports two modes: prompt-based generation and image-to-video animation.  ### How it Works  **Mode 1 - Text to Video**: Provide a text prompt and the API generates a video based on the description.   **Mode 2 - Image to Video**: Select a previously generated image and optionally add a prompt. The API animates the image, bringing it to life with motion.  Processing takes 3-5 minutes depending on quality settings. Videos are 4 seconds long.  ### Required Parameters  **For Text Mode**:  - &#x60;prompt&#x60; - Video generation prompt (1-8192 characters)      - &#x60;videoType&#x60; - Quality: 0&#x3D;480p (faster), 1&#x3D;720p (higher quality)       **For Image Animation Mode**:  - &#x60;jobId&#x60; - UUID of source image generation task      - &#x60;imageNo&#x60; - Image number to animate (0, 1, 2, or 3)      - &#x60;prompt&#x60; - Optional prompt to guide animation (1-8192 characters)      - &#x60;videoType&#x60; - Quality: 0&#x3D;480p (faster), 1&#x3D;720p (higher quality)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The generated videos (4 variations) will be sent to your callback URL when complete (typically 3-5 minutes).  ### Use Cases  - Create animated content from text descriptions      - Bring static generated images to life with animation      - Generate video content for social media      - Create motion graphics and animated sequences      - Produce video mockups and previews       ### Tips  - 720p quality takes longer but provides significantly better results      - Image animation mode adds motion to existing images      - 4-second duration is standard - use extend-video to lengthen      - Prompt in image mode guides animation style and movement      - Text mode generates both visual content and motion
        /// </remarks>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1VideoDiffusionPostApiResponse"/>?&gt;</returns>
        Task<IApiV1VideoDiffusionPostApiResponse?> ApiV1VideoDiffusionPostOrDefaultAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Video Upscale
        /// </summary>
        /// <remarks>
        /// ## Enhance Video Resolution and Quality  Upscale generated videos to higher resolution with AI-powered quality enhancement. Improves clarity, detail, and overall visual quality.  ### How it Works  Select a previously generated video and the API processes each frame to increase resolution and enhance quality while maintaining motion smoothness and temporal consistency.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original video generation task      - &#x60;videoNo&#x60; - Video number to upscale (0, 1, 2, or 3)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The upscaled video will be sent to your callback URL when complete (typically 4-6 minutes).  ### Use Cases  - Prepare videos for high-resolution displays      - Enhance quality of draft-quality generations      - Create production-ready video assets      - Improve detail and clarity for professional use      - Upgrade videos for client presentations       ### Tips  - Significantly increases processing time due to frame-by-frame enhancement      - Best applied after you&#39;ve selected your preferred video variation      - Cannot be reversed - always keep original lower-resolution version      - Quality improvement is substantial for text clarity and fine details      - Consider workflow: generate/extend first, upscale final selection
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1VideoUpscalePostApiResponse"/>&gt;</returns>
        Task<IApiV1VideoUpscalePostApiResponse> ApiV1VideoUpscalePostAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Video Upscale
        /// </summary>
        /// <remarks>
        /// ## Enhance Video Resolution and Quality  Upscale generated videos to higher resolution with AI-powered quality enhancement. Improves clarity, detail, and overall visual quality.  ### How it Works  Select a previously generated video and the API processes each frame to increase resolution and enhance quality while maintaining motion smoothness and temporal consistency.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original video generation task      - &#x60;videoNo&#x60; - Video number to upscale (0, 1, 2, or 3)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The upscaled video will be sent to your callback URL when complete (typically 4-6 minutes).  ### Use Cases  - Prepare videos for high-resolution displays      - Enhance quality of draft-quality generations      - Create production-ready video assets      - Improve detail and clarity for professional use      - Upgrade videos for client presentations       ### Tips  - Significantly increases processing time due to frame-by-frame enhancement      - Best applied after you&#39;ve selected your preferred video variation      - Cannot be reversed - always keep original lower-resolution version      - Quality improvement is substantial for text clarity and fine details      - Consider workflow: generate/extend first, upscale final selection
        /// </remarks>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1VideoUpscalePostApiResponse"/>?&gt;</returns>
        Task<IApiV1VideoUpscalePostApiResponse?> ApiV1VideoUpscalePostOrDefaultAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IApiV1ExtendVideoPostApiResponse"/>
    /// </summary>
    public interface IApiV1ExtendVideoPostApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.TaskResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IApiV1JobJobIdGetApiResponse"/>
    /// </summary>
    public interface IApiV1JobJobIdGetApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ApiV1JobJobIdGet200Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IApiV1VideoDiffusionPostApiResponse"/>
    /// </summary>
    public interface IApiV1VideoDiffusionPostApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.TaskResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IApiV1VideoUpscalePostApiResponse"/>
    /// </summary>
    public interface IApiV1VideoUpscalePostApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.TaskResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class VideoApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnApiV1ExtendVideoPost;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorApiV1ExtendVideoPost;

        internal void ExecuteOnApiV1ExtendVideoPost(VideoApi.ApiV1ExtendVideoPostApiResponse apiResponse)
        {
            OnApiV1ExtendVideoPost?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorApiV1ExtendVideoPost(Exception exception)
        {
            OnErrorApiV1ExtendVideoPost?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnApiV1JobJobIdGet;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorApiV1JobJobIdGet;

        internal void ExecuteOnApiV1JobJobIdGet(VideoApi.ApiV1JobJobIdGetApiResponse apiResponse)
        {
            OnApiV1JobJobIdGet?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorApiV1JobJobIdGet(Exception exception)
        {
            OnErrorApiV1JobJobIdGet?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnApiV1VideoDiffusionPost;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorApiV1VideoDiffusionPost;

        internal void ExecuteOnApiV1VideoDiffusionPost(VideoApi.ApiV1VideoDiffusionPostApiResponse apiResponse)
        {
            OnApiV1VideoDiffusionPost?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorApiV1VideoDiffusionPost(Exception exception)
        {
            OnErrorApiV1VideoDiffusionPost?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnApiV1VideoUpscalePost;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorApiV1VideoUpscalePost;

        internal void ExecuteOnApiV1VideoUpscalePost(VideoApi.ApiV1VideoUpscalePostApiResponse apiResponse)
        {
            OnApiV1VideoUpscalePost?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorApiV1VideoUpscalePost(Exception exception)
        {
            OnErrorApiV1VideoUpscalePost?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class VideoApi : IVideoApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<VideoApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public VideoApiEvents Events { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="VideoApi"/> class.
        /// </summary>
        /// <returns></returns>
        public VideoApi(ILogger<VideoApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, VideoApiEvents videoApiEvents)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<VideoApi>();
            HttpClient = httpClient;
            Events = videoApiEvents;
        }

        partial void FormatApiV1ExtendVideoPost(ref Option<string> xApiKey, ref Option<Object> body);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        private void ValidateApiV1ExtendVideoPost(Option<string> xApiKey, Option<Object> body)
        {
            if (xApiKey.IsSet && xApiKey.Value == null)
                throw new ArgumentNullException(nameof(xApiKey));

            if (body.IsSet && body.Value == null)
                throw new ArgumentNullException(nameof(body));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void AfterApiV1ExtendVideoPostDefaultImplementation(IApiV1ExtendVideoPostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<Object> body)
        {
            bool suppressDefaultLog = false;
            AfterApiV1ExtendVideoPost(ref suppressDefaultLog, apiResponseLocalVar, xApiKey, body);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void AfterApiV1ExtendVideoPost(ref bool suppressDefaultLog, IApiV1ExtendVideoPostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<Object> body);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void OnErrorApiV1ExtendVideoPostDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<Object> body)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorApiV1ExtendVideoPost(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, xApiKey, body);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void OnErrorApiV1ExtendVideoPost(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<Object> body);

        /// <summary>
        /// Extend Video ## Extend Video Duration with Seamless Continuation  Add additional frames to extend the duration of generated videos. Creates smooth continuations that seamlessly flow from the original video.  ### How it Works  Select a previously generated video and optionally provide a prompt to guide the extension. The API analyzes the video&#39;s motion and content, then generates additional frames that naturally continue the sequence. Each extension adds 4 seconds.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original video generation task      - &#x60;videoNo&#x60; - Video number to extend (0, 1, 2, or 3)      - &#x60;prompt&#x60; - Optional prompt to guide the extension (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The extended video will be sent to your callback URL when complete (typically 3-5 minutes).  ### Use Cases  - Create longer videos from initial 4-second generations      - Extend successful animations for more content      - Build sequential video narratives      - Generate longer social media content      - Create extended motion sequences       ### Tips  - Each extension adds 4 seconds to the video      - Can extend up to 4 times (maximum 20 seconds total: 4+4+4+4+4)      - Prompt helps guide what happens in the extended portion      - Extension quality depends on the source video&#39;s clarity and motion      - Works with both text-generated and image-animated videos
        /// </summary>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1ExtendVideoPostApiResponse"/>&gt;</returns>
        public async Task<IApiV1ExtendVideoPostApiResponse?> ApiV1ExtendVideoPostOrDefaultAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ApiV1ExtendVideoPostAsync(xApiKey, body, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Extend Video ## Extend Video Duration with Seamless Continuation  Add additional frames to extend the duration of generated videos. Creates smooth continuations that seamlessly flow from the original video.  ### How it Works  Select a previously generated video and optionally provide a prompt to guide the extension. The API analyzes the video&#39;s motion and content, then generates additional frames that naturally continue the sequence. Each extension adds 4 seconds.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original video generation task      - &#x60;videoNo&#x60; - Video number to extend (0, 1, 2, or 3)      - &#x60;prompt&#x60; - Optional prompt to guide the extension (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The extended video will be sent to your callback URL when complete (typically 3-5 minutes).  ### Use Cases  - Create longer videos from initial 4-second generations      - Extend successful animations for more content      - Build sequential video narratives      - Generate longer social media content      - Create extended motion sequences       ### Tips  - Each extension adds 4 seconds to the video      - Can extend up to 4 times (maximum 20 seconds total: 4+4+4+4+4)      - Prompt helps guide what happens in the extended portion      - Extension quality depends on the source video&#39;s clarity and motion      - Works with both text-generated and image-animated videos
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1ExtendVideoPostApiResponse"/>&gt;</returns>
        public async Task<IApiV1ExtendVideoPostApiResponse> ApiV1ExtendVideoPostAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateApiV1ExtendVideoPost(xApiKey, body);

                FormatApiV1ExtendVideoPost(ref xApiKey, ref body);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/extend-video"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/extend-video");

                    if (xApiKey.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("x-api-key", ClientUtils.ParameterToString(xApiKey.Value));

                    if (body.IsSet)
                        httpRequestMessageLocalVar.Content = (body.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(body.Value, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ApiV1ExtendVideoPostApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ApiV1ExtendVideoPostApiResponse>();
                        ApiV1ExtendVideoPostApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/extend-video", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterApiV1ExtendVideoPostDefaultImplementation(apiResponseLocalVar, xApiKey, body);

                        Events.ExecuteOnApiV1ExtendVideoPost(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorApiV1ExtendVideoPostDefaultImplementation(e, "/api/v1/extend-video", uriBuilderLocalVar.Path, xApiKey, body);
                Events.ExecuteOnErrorApiV1ExtendVideoPost(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ApiV1ExtendVideoPostApiResponse"/>
        /// </summary>
        public partial class ApiV1ExtendVideoPostApiResponse : Org.OpenAPITools.Client.ApiResponse, IApiV1ExtendVideoPostApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ApiV1ExtendVideoPostApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ApiV1ExtendVideoPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1ExtendVideoPostApiResponse(ILogger<ApiV1ExtendVideoPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ApiV1ExtendVideoPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1ExtendVideoPostApiResponse(ILogger<ApiV1ExtendVideoPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.TaskResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.TaskResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.TaskResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatApiV1JobJobIdGet(ref string jobId, ref Option<string> xApiKey);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="jobId"></param>
        /// <param name="xApiKey"></param>
        /// <returns></returns>
        private void ValidateApiV1JobJobIdGet(string jobId, Option<string> xApiKey)
        {
            if (jobId == null)
                throw new ArgumentNullException(nameof(jobId));

            if (xApiKey.IsSet && xApiKey.Value == null)
                throw new ArgumentNullException(nameof(xApiKey));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="jobId"></param>
        /// <param name="xApiKey"></param>
        private void AfterApiV1JobJobIdGetDefaultImplementation(IApiV1JobJobIdGetApiResponse apiResponseLocalVar, string jobId, Option<string> xApiKey)
        {
            bool suppressDefaultLog = false;
            AfterApiV1JobJobIdGet(ref suppressDefaultLog, apiResponseLocalVar, jobId, xApiKey);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="jobId"></param>
        /// <param name="xApiKey"></param>
        partial void AfterApiV1JobJobIdGet(ref bool suppressDefaultLog, IApiV1JobJobIdGetApiResponse apiResponseLocalVar, string jobId, Option<string> xApiKey);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="jobId"></param>
        /// <param name="xApiKey"></param>
        private void OnErrorApiV1JobJobIdGetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string jobId, Option<string> xApiKey)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorApiV1JobJobIdGet(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, jobId, xApiKey);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="jobId"></param>
        /// <param name="xApiKey"></param>
        partial void OnErrorApiV1JobJobIdGet(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string jobId, Option<string> xApiKey);

        /// <summary>
        /// Get task response ## Retrieve Job Status and Results  Query the status and results of any task using its job ID. Use this to check progress, retrieve completed results, or diagnose failures.  ### How it Works  Provide a job ID from any previous API request. The API returns the current task status, progress information, and results (if completed). Poll this endpoint to track long-running tasks.  ### Required Parameters  - &#x60;job_id&#x60; - UUID of the task (passed in URL path)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns complete task information including:  - &#x60;status&#x60; - Current status: pending, staged, processing, failed, or completed      - &#x60;output&#x60; - Generated images/videos (null until completed)      - &#x60;meta&#x60; - Timestamps, usage information, processing details      - &#x60;error&#x60; - Error details if status is \&quot;failed\&quot;      - &#x60;logs&#x60; - Processing logs and progress updates       ### Status Values  - **pending**: Task queued, waiting to start      - **staged**: Task prepared, about to begin processing      - **processing**: Actively generating (includes progress percentage in logs)      - **completed**: Successfully finished, results available in output field      - **failed**: Processing failed, check error field for details       ### Use Cases  - Poll for task completion if not using webhooks      - Retrieve results for tasks completed days/weeks ago      - Debug failed tasks by examining error messages      - Monitor processing progress for long-running jobs      - Retrieve task history and usage information       ### Tips  - Job IDs are permanent - tasks can be retrieved anytime      - Poll every 10-30 seconds for pending tasks (avoid excessive polling)      - Webhook callbacks are more efficient than polling      - Failed tasks include detailed error messages for debugging      - Completed tasks retain all generation parameters in the input field
        /// </summary>
        /// <param name="jobId"></param>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1JobJobIdGetApiResponse"/>&gt;</returns>
        public async Task<IApiV1JobJobIdGetApiResponse?> ApiV1JobJobIdGetOrDefaultAsync(string jobId, Option<string> xApiKey = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ApiV1JobJobIdGetAsync(jobId, xApiKey, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get task response ## Retrieve Job Status and Results  Query the status and results of any task using its job ID. Use this to check progress, retrieve completed results, or diagnose failures.  ### How it Works  Provide a job ID from any previous API request. The API returns the current task status, progress information, and results (if completed). Poll this endpoint to track long-running tasks.  ### Required Parameters  - &#x60;job_id&#x60; - UUID of the task (passed in URL path)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns complete task information including:  - &#x60;status&#x60; - Current status: pending, staged, processing, failed, or completed      - &#x60;output&#x60; - Generated images/videos (null until completed)      - &#x60;meta&#x60; - Timestamps, usage information, processing details      - &#x60;error&#x60; - Error details if status is \&quot;failed\&quot;      - &#x60;logs&#x60; - Processing logs and progress updates       ### Status Values  - **pending**: Task queued, waiting to start      - **staged**: Task prepared, about to begin processing      - **processing**: Actively generating (includes progress percentage in logs)      - **completed**: Successfully finished, results available in output field      - **failed**: Processing failed, check error field for details       ### Use Cases  - Poll for task completion if not using webhooks      - Retrieve results for tasks completed days/weeks ago      - Debug failed tasks by examining error messages      - Monitor processing progress for long-running jobs      - Retrieve task history and usage information       ### Tips  - Job IDs are permanent - tasks can be retrieved anytime      - Poll every 10-30 seconds for pending tasks (avoid excessive polling)      - Webhook callbacks are more efficient than polling      - Failed tasks include detailed error messages for debugging      - Completed tasks retain all generation parameters in the input field
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="jobId"></param>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1JobJobIdGetApiResponse"/>&gt;</returns>
        public async Task<IApiV1JobJobIdGetApiResponse> ApiV1JobJobIdGetAsync(string jobId, Option<string> xApiKey = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateApiV1JobJobIdGet(jobId, xApiKey);

                FormatApiV1JobJobIdGet(ref jobId, ref xApiKey);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/job/{job_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/job/{job_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bjob_id%7D", Uri.EscapeDataString(jobId.ToString()));

                    if (xApiKey.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("x-api-key", ClientUtils.ParameterToString(xApiKey.Value));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ApiV1JobJobIdGetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ApiV1JobJobIdGetApiResponse>();
                        ApiV1JobJobIdGetApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/job/{job_id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterApiV1JobJobIdGetDefaultImplementation(apiResponseLocalVar, jobId, xApiKey);

                        Events.ExecuteOnApiV1JobJobIdGet(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorApiV1JobJobIdGetDefaultImplementation(e, "/api/v1/job/{job_id}", uriBuilderLocalVar.Path, jobId, xApiKey);
                Events.ExecuteOnErrorApiV1JobJobIdGet(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ApiV1JobJobIdGetApiResponse"/>
        /// </summary>
        public partial class ApiV1JobJobIdGetApiResponse : Org.OpenAPITools.Client.ApiResponse, IApiV1JobJobIdGetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ApiV1JobJobIdGetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ApiV1JobJobIdGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1JobJobIdGetApiResponse(ILogger<ApiV1JobJobIdGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ApiV1JobJobIdGetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1JobJobIdGetApiResponse(ILogger<ApiV1JobJobIdGetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ApiV1JobJobIdGet200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ApiV1JobJobIdGet200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ApiV1JobJobIdGet200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatApiV1VideoDiffusionPost(ref Option<string> xApiKey, ref Option<Object> body);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        private void ValidateApiV1VideoDiffusionPost(Option<string> xApiKey, Option<Object> body)
        {
            if (xApiKey.IsSet && xApiKey.Value == null)
                throw new ArgumentNullException(nameof(xApiKey));

            if (body.IsSet && body.Value == null)
                throw new ArgumentNullException(nameof(body));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void AfterApiV1VideoDiffusionPostDefaultImplementation(IApiV1VideoDiffusionPostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<Object> body)
        {
            bool suppressDefaultLog = false;
            AfterApiV1VideoDiffusionPost(ref suppressDefaultLog, apiResponseLocalVar, xApiKey, body);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void AfterApiV1VideoDiffusionPost(ref bool suppressDefaultLog, IApiV1VideoDiffusionPostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<Object> body);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void OnErrorApiV1VideoDiffusionPostDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<Object> body)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorApiV1VideoDiffusionPost(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, xApiKey, body);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void OnErrorApiV1VideoDiffusionPost(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<Object> body);

        /// <summary>
        /// Video Diffusion ## Generate Videos from Text or Animate Images  Create dynamic videos either from text prompts or by animating existing generated images. Supports two modes: prompt-based generation and image-to-video animation.  ### How it Works  **Mode 1 - Text to Video**: Provide a text prompt and the API generates a video based on the description.   **Mode 2 - Image to Video**: Select a previously generated image and optionally add a prompt. The API animates the image, bringing it to life with motion.  Processing takes 3-5 minutes depending on quality settings. Videos are 4 seconds long.  ### Required Parameters  **For Text Mode**:  - &#x60;prompt&#x60; - Video generation prompt (1-8192 characters)      - &#x60;videoType&#x60; - Quality: 0&#x3D;480p (faster), 1&#x3D;720p (higher quality)       **For Image Animation Mode**:  - &#x60;jobId&#x60; - UUID of source image generation task      - &#x60;imageNo&#x60; - Image number to animate (0, 1, 2, or 3)      - &#x60;prompt&#x60; - Optional prompt to guide animation (1-8192 characters)      - &#x60;videoType&#x60; - Quality: 0&#x3D;480p (faster), 1&#x3D;720p (higher quality)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The generated videos (4 variations) will be sent to your callback URL when complete (typically 3-5 minutes).  ### Use Cases  - Create animated content from text descriptions      - Bring static generated images to life with animation      - Generate video content for social media      - Create motion graphics and animated sequences      - Produce video mockups and previews       ### Tips  - 720p quality takes longer but provides significantly better results      - Image animation mode adds motion to existing images      - 4-second duration is standard - use extend-video to lengthen      - Prompt in image mode guides animation style and movement      - Text mode generates both visual content and motion
        /// </summary>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1VideoDiffusionPostApiResponse"/>&gt;</returns>
        public async Task<IApiV1VideoDiffusionPostApiResponse?> ApiV1VideoDiffusionPostOrDefaultAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ApiV1VideoDiffusionPostAsync(xApiKey, body, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Video Diffusion ## Generate Videos from Text or Animate Images  Create dynamic videos either from text prompts or by animating existing generated images. Supports two modes: prompt-based generation and image-to-video animation.  ### How it Works  **Mode 1 - Text to Video**: Provide a text prompt and the API generates a video based on the description.   **Mode 2 - Image to Video**: Select a previously generated image and optionally add a prompt. The API animates the image, bringing it to life with motion.  Processing takes 3-5 minutes depending on quality settings. Videos are 4 seconds long.  ### Required Parameters  **For Text Mode**:  - &#x60;prompt&#x60; - Video generation prompt (1-8192 characters)      - &#x60;videoType&#x60; - Quality: 0&#x3D;480p (faster), 1&#x3D;720p (higher quality)       **For Image Animation Mode**:  - &#x60;jobId&#x60; - UUID of source image generation task      - &#x60;imageNo&#x60; - Image number to animate (0, 1, 2, or 3)      - &#x60;prompt&#x60; - Optional prompt to guide animation (1-8192 characters)      - &#x60;videoType&#x60; - Quality: 0&#x3D;480p (faster), 1&#x3D;720p (higher quality)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The generated videos (4 variations) will be sent to your callback URL when complete (typically 3-5 minutes).  ### Use Cases  - Create animated content from text descriptions      - Bring static generated images to life with animation      - Generate video content for social media      - Create motion graphics and animated sequences      - Produce video mockups and previews       ### Tips  - 720p quality takes longer but provides significantly better results      - Image animation mode adds motion to existing images      - 4-second duration is standard - use extend-video to lengthen      - Prompt in image mode guides animation style and movement      - Text mode generates both visual content and motion
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1VideoDiffusionPostApiResponse"/>&gt;</returns>
        public async Task<IApiV1VideoDiffusionPostApiResponse> ApiV1VideoDiffusionPostAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateApiV1VideoDiffusionPost(xApiKey, body);

                FormatApiV1VideoDiffusionPost(ref xApiKey, ref body);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/video-diffusion"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/video-diffusion");

                    if (xApiKey.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("x-api-key", ClientUtils.ParameterToString(xApiKey.Value));

                    if (body.IsSet)
                        httpRequestMessageLocalVar.Content = (body.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(body.Value, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ApiV1VideoDiffusionPostApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ApiV1VideoDiffusionPostApiResponse>();
                        ApiV1VideoDiffusionPostApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/video-diffusion", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterApiV1VideoDiffusionPostDefaultImplementation(apiResponseLocalVar, xApiKey, body);

                        Events.ExecuteOnApiV1VideoDiffusionPost(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorApiV1VideoDiffusionPostDefaultImplementation(e, "/api/v1/video-diffusion", uriBuilderLocalVar.Path, xApiKey, body);
                Events.ExecuteOnErrorApiV1VideoDiffusionPost(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ApiV1VideoDiffusionPostApiResponse"/>
        /// </summary>
        public partial class ApiV1VideoDiffusionPostApiResponse : Org.OpenAPITools.Client.ApiResponse, IApiV1VideoDiffusionPostApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ApiV1VideoDiffusionPostApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ApiV1VideoDiffusionPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1VideoDiffusionPostApiResponse(ILogger<ApiV1VideoDiffusionPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ApiV1VideoDiffusionPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1VideoDiffusionPostApiResponse(ILogger<ApiV1VideoDiffusionPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.TaskResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.TaskResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.TaskResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatApiV1VideoUpscalePost(ref Option<string> xApiKey, ref Option<Object> body);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        private void ValidateApiV1VideoUpscalePost(Option<string> xApiKey, Option<Object> body)
        {
            if (xApiKey.IsSet && xApiKey.Value == null)
                throw new ArgumentNullException(nameof(xApiKey));

            if (body.IsSet && body.Value == null)
                throw new ArgumentNullException(nameof(body));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void AfterApiV1VideoUpscalePostDefaultImplementation(IApiV1VideoUpscalePostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<Object> body)
        {
            bool suppressDefaultLog = false;
            AfterApiV1VideoUpscalePost(ref suppressDefaultLog, apiResponseLocalVar, xApiKey, body);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void AfterApiV1VideoUpscalePost(ref bool suppressDefaultLog, IApiV1VideoUpscalePostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<Object> body);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void OnErrorApiV1VideoUpscalePostDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<Object> body)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorApiV1VideoUpscalePost(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, xApiKey, body);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void OnErrorApiV1VideoUpscalePost(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<Object> body);

        /// <summary>
        /// Video Upscale ## Enhance Video Resolution and Quality  Upscale generated videos to higher resolution with AI-powered quality enhancement. Improves clarity, detail, and overall visual quality.  ### How it Works  Select a previously generated video and the API processes each frame to increase resolution and enhance quality while maintaining motion smoothness and temporal consistency.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original video generation task      - &#x60;videoNo&#x60; - Video number to upscale (0, 1, 2, or 3)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The upscaled video will be sent to your callback URL when complete (typically 4-6 minutes).  ### Use Cases  - Prepare videos for high-resolution displays      - Enhance quality of draft-quality generations      - Create production-ready video assets      - Improve detail and clarity for professional use      - Upgrade videos for client presentations       ### Tips  - Significantly increases processing time due to frame-by-frame enhancement      - Best applied after you&#39;ve selected your preferred video variation      - Cannot be reversed - always keep original lower-resolution version      - Quality improvement is substantial for text clarity and fine details      - Consider workflow: generate/extend first, upscale final selection
        /// </summary>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1VideoUpscalePostApiResponse"/>&gt;</returns>
        public async Task<IApiV1VideoUpscalePostApiResponse?> ApiV1VideoUpscalePostOrDefaultAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ApiV1VideoUpscalePostAsync(xApiKey, body, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Video Upscale ## Enhance Video Resolution and Quality  Upscale generated videos to higher resolution with AI-powered quality enhancement. Improves clarity, detail, and overall visual quality.  ### How it Works  Select a previously generated video and the API processes each frame to increase resolution and enhance quality while maintaining motion smoothness and temporal consistency.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original video generation task      - &#x60;videoNo&#x60; - Video number to upscale (0, 1, 2, or 3)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The upscaled video will be sent to your callback URL when complete (typically 4-6 minutes).  ### Use Cases  - Prepare videos for high-resolution displays      - Enhance quality of draft-quality generations      - Create production-ready video assets      - Improve detail and clarity for professional use      - Upgrade videos for client presentations       ### Tips  - Significantly increases processing time due to frame-by-frame enhancement      - Best applied after you&#39;ve selected your preferred video variation      - Cannot be reversed - always keep original lower-resolution version      - Quality improvement is substantial for text clarity and fine details      - Consider workflow: generate/extend first, upscale final selection
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1VideoUpscalePostApiResponse"/>&gt;</returns>
        public async Task<IApiV1VideoUpscalePostApiResponse> ApiV1VideoUpscalePostAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateApiV1VideoUpscalePost(xApiKey, body);

                FormatApiV1VideoUpscalePost(ref xApiKey, ref body);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/video-upscale"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/video-upscale");

                    if (xApiKey.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("x-api-key", ClientUtils.ParameterToString(xApiKey.Value));

                    if (body.IsSet)
                        httpRequestMessageLocalVar.Content = (body.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(body.Value, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ApiV1VideoUpscalePostApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ApiV1VideoUpscalePostApiResponse>();
                        ApiV1VideoUpscalePostApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/video-upscale", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterApiV1VideoUpscalePostDefaultImplementation(apiResponseLocalVar, xApiKey, body);

                        Events.ExecuteOnApiV1VideoUpscalePost(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorApiV1VideoUpscalePostDefaultImplementation(e, "/api/v1/video-upscale", uriBuilderLocalVar.Path, xApiKey, body);
                Events.ExecuteOnErrorApiV1VideoUpscalePost(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ApiV1VideoUpscalePostApiResponse"/>
        /// </summary>
        public partial class ApiV1VideoUpscalePostApiResponse : Org.OpenAPITools.Client.ApiResponse, IApiV1VideoUpscalePostApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ApiV1VideoUpscalePostApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ApiV1VideoUpscalePostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1VideoUpscalePostApiResponse(ILogger<ApiV1VideoUpscalePostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ApiV1VideoUpscalePostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1VideoUpscalePostApiResponse(ILogger<ApiV1VideoUpscalePostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.TaskResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.TaskResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.TaskResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
