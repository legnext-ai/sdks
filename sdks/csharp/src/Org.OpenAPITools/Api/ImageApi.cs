// <auto-generated>
/*
 * Midjourney api-unofficial by Legnext.ai
 *
 * # **Legnext.ai Midjourney API: The Ultimate AI Image Generation Toolkit**  Unlock the full creative potential of Midjourney directly within your applications and development workflows using the **Legnext.ai Midjourney API (Unofficial)**. This comprehensive collection offers a ready-to-integrate solution for professional image and video creation, manipulation, and high-fidelity upscaling.  We provide developers with **stable, high-performance API access** to the Midjourney model. Crucially, integrating our service requires **no Midjourney account**, eliminating the hassle of managing official subscriptions or Discord interactions. Our toolkit simplifies the entire text-to-image process, supporting complex prompts, aspect ratio adjustments, and advanced style parameters.  Focus on innovation while we handle the AI infrastructure. Start building scalable, visually stunning applications today with reliable access to the worldâ€™s leading generative AI model.
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Org.OpenAPITools.Client;
using Org.OpenAPITools.Model;
using System.Diagnostics.CodeAnalysis;

namespace Org.OpenAPITools.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IImageApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        ImageApiEvents Events { get; }

        /// <summary>
        /// Blend
        /// </summary>
        /// <remarks>
        /// ## Combine Multiple Images into Unified Creation  Seamlessly blend 2-5 images together to create a single unique image that combines elements, styles, and concepts from all source images.  ### How it Works  Upload 2-5 image URLs and specify an aspect ratio. The API analyzes all images and creates a cohesive blend that merges their visual elements, colors, styles, and concepts.  ### Required Parameters  - &#x60;imgUrls&#x60; - Array of 2-5 image URLs to blend      - &#x60;aspect_ratio&#x60; - Output aspect ratio: \&quot;2:3\&quot; (portrait), \&quot;1:1\&quot; (square), or \&quot;3:2\&quot; (landscape)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The blended images (4 variations) will be sent to your callback URL when complete (typically 60-90 seconds).  ### Use Cases  - Combine style references for unique visual concepts      - Merge product photos with artistic styles      - Create hybrid concepts from multiple references      - Blend textures and patterns for design work      - Mix character designs or architectural styles       ### Tips  - Works best with 2-3 images; more images create more abstract results      - All source images should be publicly accessible URLs      - The blend is conceptual, not a simple overlay      - Consider the aspect ratio based on your intended use      - Experiment with different image composition, color palettes, or subject matter for varied results.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1BlendPostApiResponse"/>&gt;</returns>
        Task<IApiV1BlendPostApiResponse> ApiV1BlendPostAsync(Option<string> xApiKey = default, Option<string> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Blend
        /// </summary>
        /// <remarks>
        /// ## Combine Multiple Images into Unified Creation  Seamlessly blend 2-5 images together to create a single unique image that combines elements, styles, and concepts from all source images.  ### How it Works  Upload 2-5 image URLs and specify an aspect ratio. The API analyzes all images and creates a cohesive blend that merges their visual elements, colors, styles, and concepts.  ### Required Parameters  - &#x60;imgUrls&#x60; - Array of 2-5 image URLs to blend      - &#x60;aspect_ratio&#x60; - Output aspect ratio: \&quot;2:3\&quot; (portrait), \&quot;1:1\&quot; (square), or \&quot;3:2\&quot; (landscape)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The blended images (4 variations) will be sent to your callback URL when complete (typically 60-90 seconds).  ### Use Cases  - Combine style references for unique visual concepts      - Merge product photos with artistic styles      - Create hybrid concepts from multiple references      - Blend textures and patterns for design work      - Mix character designs or architectural styles       ### Tips  - Works best with 2-3 images; more images create more abstract results      - All source images should be publicly accessible URLs      - The blend is conceptual, not a simple overlay      - Consider the aspect ratio based on your intended use      - Experiment with different image composition, color palettes, or subject matter for varied results.
        /// </remarks>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1BlendPostApiResponse"/>?&gt;</returns>
        Task<IApiV1BlendPostApiResponse?> ApiV1BlendPostOrDefaultAsync(Option<string> xApiKey = default, Option<string> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Describe
        /// </summary>
        /// <remarks>
        /// ## Generate Detailed Text Descriptions from Images  Analyze an image and generate detailed text descriptions that can be used as prompts for image generation. Perfect for reverse-engineering images or creating prompt variations.  ### How it Works  Provide an image URL and the API analyzes the image using AI, generating 4 different text descriptions that capture the image&#39;s content, style, mood, and composition.  ### Required Parameters  - &#x60;imgUrl&#x60; - Public URL of the image to analyze and describe       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The generated descriptions (typically 4 variations) will be sent to your callback URL when complete (typically 30-60 seconds).  ### Use Cases  - Reverse-engineer successful images to understand prompt styles      - Generate prompt variations from reference images      - Create training data for prompt engineering      - Document image libraries with AI-generated descriptions      - Learn effective prompt writing by analyzing AI descriptions       ### Tips  - Image URL must be publicly accessible      - Descriptions can be used directly as prompts for diffusion endpoint      - Each description offers a different perspective/focus on the image      - Useful for building prompt libraries from visual references      - Combine with your own modifications for customized prompts
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1DescribePostApiResponse"/>&gt;</returns>
        Task<IApiV1DescribePostApiResponse> ApiV1DescribePostAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Describe
        /// </summary>
        /// <remarks>
        /// ## Generate Detailed Text Descriptions from Images  Analyze an image and generate detailed text descriptions that can be used as prompts for image generation. Perfect for reverse-engineering images or creating prompt variations.  ### How it Works  Provide an image URL and the API analyzes the image using AI, generating 4 different text descriptions that capture the image&#39;s content, style, mood, and composition.  ### Required Parameters  - &#x60;imgUrl&#x60; - Public URL of the image to analyze and describe       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The generated descriptions (typically 4 variations) will be sent to your callback URL when complete (typically 30-60 seconds).  ### Use Cases  - Reverse-engineer successful images to understand prompt styles      - Generate prompt variations from reference images      - Create training data for prompt engineering      - Document image libraries with AI-generated descriptions      - Learn effective prompt writing by analyzing AI descriptions       ### Tips  - Image URL must be publicly accessible      - Descriptions can be used directly as prompts for diffusion endpoint      - Each description offers a different perspective/focus on the image      - Useful for building prompt libraries from visual references      - Combine with your own modifications for customized prompts
        /// </remarks>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1DescribePostApiResponse"/>?&gt;</returns>
        Task<IApiV1DescribePostApiResponse?> ApiV1DescribePostOrDefaultAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Diffusion
        /// </summary>
        /// <remarks>
        /// ## Generate Image from Text Prompt (Diffusion)  Creates AI-generated images from text descriptions using Midjourney&#39;s diffusion model. This endpoint processes your prompt asynchronously and delivers the generated image to your specified callback URL.  ### How It Works  Submit a text prompt describing the image you want to create. The API processes your request using Midjourney&#39;s AI model and sends the generated image result to your callback URL when complete. Processing typically takes 30-90 seconds depending on complexity and queue length.  ### Required Parameters  - **&#x60;text&#x60;** (string, required) - Your image description prompt          - Example: &#x60;\&quot;A beautiful sunset over the snow mountains\&quot;&#x60;              - Supports Midjourney parameters like &#x60;- -v 7&#x60; (model version), &#x60;- -draft&#x60; (draft mode), &#x60;- -ar 16:9&#x60; (aspect ratio)              - Be specific and descriptive for best results          - **&#x60;callback&#x60;** (string, required) - HTTPS webhook URL to receive the result          - Must be publicly accessible and accept POST requests              - Example: &#x60;\&quot;https://your-domain.com/webhook/image-result\&quot;&#x60;              - The API will send the generated image data to this URL when processing completes           ### Authentication  Requires a valid API key in the &#x60;x-api-key&#x60; header. Store your API key securely in environment variables and never expose it in client-side code.  ### Response  Returns immediately with a task ID and status. The actual generated image will be delivered to your callback URL asynchronously once processing completes.  ### Common Use Cases  - Generate marketing visuals and social media content      - Create concept art and design mockups      - Produce unique illustrations for articles and presentations      - Prototype visual ideas before commissioning custom artwork      - Build AI-powered image generation features into your applications       ### Tips for Success  - **Be specific:** Detailed prompts produce better results (e.g., \&quot;photorealistic mountain landscape at golden hour\&quot; vs \&quot;mountains\&quot;)      - **Use Midjourney parameters:** Add &#x60;- -v 7&#x60; for the latest model version, &#x60;- -ar 16:9&#x60; for widescreen format      - **Test your callback:** Ensure your webhook endpoint is accessible and can handle POST requests before submitting jobs      - **Handle async responses:** Implement proper webhook handling to receive and process results      - **Monitor task status:** Use the \&quot;Get task response\&quot; endpoint if you need to check job status manually       ### Related Endpoints  - **Get task response** - Check the status of your generation task      - **Variation** - Create variations of a generated image      - **Upscale** - Enhance the resolution of generated images      - **Reroll** - Generate alternative versions with the same prompt
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1DiffusionPostApiResponse"/>&gt;</returns>
        Task<IApiV1DiffusionPostApiResponse> ApiV1DiffusionPostAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Diffusion
        /// </summary>
        /// <remarks>
        /// ## Generate Image from Text Prompt (Diffusion)  Creates AI-generated images from text descriptions using Midjourney&#39;s diffusion model. This endpoint processes your prompt asynchronously and delivers the generated image to your specified callback URL.  ### How It Works  Submit a text prompt describing the image you want to create. The API processes your request using Midjourney&#39;s AI model and sends the generated image result to your callback URL when complete. Processing typically takes 30-90 seconds depending on complexity and queue length.  ### Required Parameters  - **&#x60;text&#x60;** (string, required) - Your image description prompt          - Example: &#x60;\&quot;A beautiful sunset over the snow mountains\&quot;&#x60;              - Supports Midjourney parameters like &#x60;- -v 7&#x60; (model version), &#x60;- -draft&#x60; (draft mode), &#x60;- -ar 16:9&#x60; (aspect ratio)              - Be specific and descriptive for best results          - **&#x60;callback&#x60;** (string, required) - HTTPS webhook URL to receive the result          - Must be publicly accessible and accept POST requests              - Example: &#x60;\&quot;https://your-domain.com/webhook/image-result\&quot;&#x60;              - The API will send the generated image data to this URL when processing completes           ### Authentication  Requires a valid API key in the &#x60;x-api-key&#x60; header. Store your API key securely in environment variables and never expose it in client-side code.  ### Response  Returns immediately with a task ID and status. The actual generated image will be delivered to your callback URL asynchronously once processing completes.  ### Common Use Cases  - Generate marketing visuals and social media content      - Create concept art and design mockups      - Produce unique illustrations for articles and presentations      - Prototype visual ideas before commissioning custom artwork      - Build AI-powered image generation features into your applications       ### Tips for Success  - **Be specific:** Detailed prompts produce better results (e.g., \&quot;photorealistic mountain landscape at golden hour\&quot; vs \&quot;mountains\&quot;)      - **Use Midjourney parameters:** Add &#x60;- -v 7&#x60; for the latest model version, &#x60;- -ar 16:9&#x60; for widescreen format      - **Test your callback:** Ensure your webhook endpoint is accessible and can handle POST requests before submitting jobs      - **Handle async responses:** Implement proper webhook handling to receive and process results      - **Monitor task status:** Use the \&quot;Get task response\&quot; endpoint if you need to check job status manually       ### Related Endpoints  - **Get task response** - Check the status of your generation task      - **Variation** - Create variations of a generated image      - **Upscale** - Enhance the resolution of generated images      - **Reroll** - Generate alternative versions with the same prompt
        /// </remarks>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1DiffusionPostApiResponse"/>?&gt;</returns>
        Task<IApiV1DiffusionPostApiResponse?> ApiV1DiffusionPostOrDefaultAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Edit
        /// </summary>
        /// <remarks>
        /// ## Edit Images with Custom Canvas and Positioning  Perform advanced image editing by placing an image on a custom canvas with precise positioning control. Enables complex edits, extensions, and compositions.  ### How it Works  Place a selected image on a custom-sized canvas at specified coordinates. The API fills empty canvas areas with generated content based on your prompt, allowing for flexible composition and extensions.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original image generation task      - &#x60;imageNo&#x60; - Image number to edit (0, 1, 2, or 3)      - &#x60;canvas&#x60; - Target canvas dimensions:          - &#x60;width&#x60; - Canvas width in pixels              - &#x60;height&#x60; - Canvas height in pixels          - &#x60;imgPos&#x60; - Image position on canvas:          - &#x60;width&#x60; - Image width in pixels              - &#x60;height&#x60; - Image height in pixels              - &#x60;x&#x60; - Horizontal offset from canvas top-left              - &#x60;y&#x60; - Vertical offset from canvas top-left          - &#x60;remixPrompt&#x60; - Prompt for filling empty canvas areas (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The edited images (4 variations) will be sent to your callback URL when complete (typically 90-120 seconds).  ### Use Cases  - Create complex compositions with custom layouts      - Extend images asymmetrically in specific directions      - Place subjects in entirely new contexts      - Generate custom aspect ratios with filled backgrounds      - Build complex scenes by positioning and extending images       ### Tips  - Canvas dimensions define the final output size      - imgPos coordinates place your image within the canvas      - Empty canvas areas are generated based on remixPrompt      - More flexible than pan/outpaint for asymmetric extensions      - Useful for precise aspect ratio and positioning control
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1EditPostApiResponse"/>&gt;</returns>
        Task<IApiV1EditPostApiResponse> ApiV1EditPostAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Edit
        /// </summary>
        /// <remarks>
        /// ## Edit Images with Custom Canvas and Positioning  Perform advanced image editing by placing an image on a custom canvas with precise positioning control. Enables complex edits, extensions, and compositions.  ### How it Works  Place a selected image on a custom-sized canvas at specified coordinates. The API fills empty canvas areas with generated content based on your prompt, allowing for flexible composition and extensions.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original image generation task      - &#x60;imageNo&#x60; - Image number to edit (0, 1, 2, or 3)      - &#x60;canvas&#x60; - Target canvas dimensions:          - &#x60;width&#x60; - Canvas width in pixels              - &#x60;height&#x60; - Canvas height in pixels          - &#x60;imgPos&#x60; - Image position on canvas:          - &#x60;width&#x60; - Image width in pixels              - &#x60;height&#x60; - Image height in pixels              - &#x60;x&#x60; - Horizontal offset from canvas top-left              - &#x60;y&#x60; - Vertical offset from canvas top-left          - &#x60;remixPrompt&#x60; - Prompt for filling empty canvas areas (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The edited images (4 variations) will be sent to your callback URL when complete (typically 90-120 seconds).  ### Use Cases  - Create complex compositions with custom layouts      - Extend images asymmetrically in specific directions      - Place subjects in entirely new contexts      - Generate custom aspect ratios with filled backgrounds      - Build complex scenes by positioning and extending images       ### Tips  - Canvas dimensions define the final output size      - imgPos coordinates place your image within the canvas      - Empty canvas areas are generated based on remixPrompt      - More flexible than pan/outpaint for asymmetric extensions      - Useful for precise aspect ratio and positioning control
        /// </remarks>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1EditPostApiResponse"/>?&gt;</returns>
        Task<IApiV1EditPostApiResponse?> ApiV1EditPostOrDefaultAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Inpaint
        /// </summary>
        /// <remarks>
        /// ## Selectively Modify Image Regions with Masks  Repaint or modify specific regions within an existing image using mask-based editing. Target precise areas for changes while preserving the rest of the image.  ### How it Works  Select an image and define regions to modify using either polygon coordinates or a mask image URL. Optionally provide a prompt to guide what should appear in those regions. The API regenerates only the masked areas.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original image generation task      - &#x60;imageNo&#x60; - Image number to edit (0, 1, 2, or 3)      - &#x60;mask&#x60; - Regions to repaint (use either areas array or url):          - &#x60;areas&#x60; - Array of polygons with width, height, and points (XYXY coordinates)              - &#x60;url&#x60; - Black and white mask image URL (white areas will be repainted)          - &#x60;remixPrompt&#x60; - Optional prompt for the repaint area (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The inpainted images (4 variations) will be sent to your callback URL when complete (typically 90-120 seconds).  ### Use Cases  - Remove unwanted objects from images      - Replace specific elements while keeping surroundings      - Modify facial expressions or poses      - Change colors or textures in targeted areas      - Fix specific issues without regenerating entire image       ### Tips  - Polygon points format: \\[x1,y1, x2,y2, x3,y3, x4,y4\\] in clockwise order      - Mask images: white &#x3D; repaint, black &#x3D; keep original      - Use remixPrompt to specify what should replace masked content      - Smaller masks give more precise control      - Can apply multiple polygon areas in a single request
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1InpaintPostApiResponse"/>&gt;</returns>
        Task<IApiV1InpaintPostApiResponse> ApiV1InpaintPostAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Inpaint
        /// </summary>
        /// <remarks>
        /// ## Selectively Modify Image Regions with Masks  Repaint or modify specific regions within an existing image using mask-based editing. Target precise areas for changes while preserving the rest of the image.  ### How it Works  Select an image and define regions to modify using either polygon coordinates or a mask image URL. Optionally provide a prompt to guide what should appear in those regions. The API regenerates only the masked areas.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original image generation task      - &#x60;imageNo&#x60; - Image number to edit (0, 1, 2, or 3)      - &#x60;mask&#x60; - Regions to repaint (use either areas array or url):          - &#x60;areas&#x60; - Array of polygons with width, height, and points (XYXY coordinates)              - &#x60;url&#x60; - Black and white mask image URL (white areas will be repainted)          - &#x60;remixPrompt&#x60; - Optional prompt for the repaint area (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The inpainted images (4 variations) will be sent to your callback URL when complete (typically 90-120 seconds).  ### Use Cases  - Remove unwanted objects from images      - Replace specific elements while keeping surroundings      - Modify facial expressions or poses      - Change colors or textures in targeted areas      - Fix specific issues without regenerating entire image       ### Tips  - Polygon points format: \\[x1,y1, x2,y2, x3,y3, x4,y4\\] in clockwise order      - Mask images: white &#x3D; repaint, black &#x3D; keep original      - Use remixPrompt to specify what should replace masked content      - Smaller masks give more precise control      - Can apply multiple polygon areas in a single request
        /// </remarks>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1InpaintPostApiResponse"/>?&gt;</returns>
        Task<IApiV1InpaintPostApiResponse?> ApiV1InpaintPostOrDefaultAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Outpaint
        /// </summary>
        /// <remarks>
        /// ## Expand Images in All Directions  Extend an image uniformly in all directions using intelligent outpainting. Creates a larger canvas while maintaining the original image at the center.  ### How it Works  Select an image and specify scale factor. The API expands the canvas uniformly in all directions and generates new content that naturally continues the scene on all sides.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original image generation task      - &#x60;imageNo&#x60; - Image number to expand (0, 1, 2, or 3)      - &#x60;scale&#x60; - Extension scale ratio (1.1 to 2.0, e.g., 1.5 &#x3D; 50% larger in all directions)      - &#x60;remixPrompt&#x60; - Optional prompt to guide the outpainted areas (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The outpainted images (4 variations) will be sent to your callback URL when complete (typically 90-120 seconds).  ### Use Cases  - Add environmental context around subject-focused images      - Create wider scenes from cropped compositions      - Extend backgrounds for design flexibility      - Generate variations with different surrounding content      - Prepare images for different aspect ratios       ### Tips  - Scale range 1.1-2.0 (outpaint is more conservative than pan)      - Use remixPrompt to describe desired surrounding content      - Great for adding context without losing the original subject      - Original image remains intact at center      - Compare with pan for directional control vs. uniform expansion
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1OutpaintPostApiResponse"/>&gt;</returns>
        Task<IApiV1OutpaintPostApiResponse> ApiV1OutpaintPostAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Outpaint
        /// </summary>
        /// <remarks>
        /// ## Expand Images in All Directions  Extend an image uniformly in all directions using intelligent outpainting. Creates a larger canvas while maintaining the original image at the center.  ### How it Works  Select an image and specify scale factor. The API expands the canvas uniformly in all directions and generates new content that naturally continues the scene on all sides.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original image generation task      - &#x60;imageNo&#x60; - Image number to expand (0, 1, 2, or 3)      - &#x60;scale&#x60; - Extension scale ratio (1.1 to 2.0, e.g., 1.5 &#x3D; 50% larger in all directions)      - &#x60;remixPrompt&#x60; - Optional prompt to guide the outpainted areas (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The outpainted images (4 variations) will be sent to your callback URL when complete (typically 90-120 seconds).  ### Use Cases  - Add environmental context around subject-focused images      - Create wider scenes from cropped compositions      - Extend backgrounds for design flexibility      - Generate variations with different surrounding content      - Prepare images for different aspect ratios       ### Tips  - Scale range 1.1-2.0 (outpaint is more conservative than pan)      - Use remixPrompt to describe desired surrounding content      - Great for adding context without losing the original subject      - Original image remains intact at center      - Compare with pan for directional control vs. uniform expansion
        /// </remarks>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1OutpaintPostApiResponse"/>?&gt;</returns>
        Task<IApiV1OutpaintPostApiResponse?> ApiV1OutpaintPostOrDefaultAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Pan
        /// </summary>
        /// <remarks>
        /// ## Extend Images in Specific Direction  Expand an image in a single specified direction (up, down, left, or right) with precision scale control. Generates new content that seamlessly continues the original image.  ### How it Works  Select an image and specify direction and scale. The API extends the canvas in that direction and generates new content that naturally continues the scene, maintaining style and coherence.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original image generation task      - &#x60;imageNo&#x60; - Image number to extend (0, 1, 2, or 3)      - &#x60;direction&#x60; - Extension direction: 0&#x3D;Down, 1&#x3D;Right, 2&#x3D;Up, 3&#x3D;Left      - &#x60;scale&#x60; - Extension scale ratio (1.1 to 3.0, e.g., 1.5 &#x3D; 50% larger in that direction)      - &#x60;remixPrompt&#x60; - Optional prompt to guide the extended content (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The extended images (4 variations) will be sent to your callback URL when complete (typically 90-120 seconds).  ### Use Cases  - Create wider landscape compositions from square images      - Extend portraits to include more environmental context      - Add vertical space for text overlays or additional content      - Build panoramic views from single images      - Adjust aspect ratios for different platform requirements       ### Tips  - Use remixPrompt to specify what should appear in the extended area      - Scale 1.5 is a good starting point (50% extension)      - Higher scales (2.0-3.0) create more new content but may lose coherence      - Works directionally - use outpaint for all-direction expansion      - Can be applied multiple times in different directions
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1PanPostApiResponse"/>&gt;</returns>
        Task<IApiV1PanPostApiResponse> ApiV1PanPostAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Pan
        /// </summary>
        /// <remarks>
        /// ## Extend Images in Specific Direction  Expand an image in a single specified direction (up, down, left, or right) with precision scale control. Generates new content that seamlessly continues the original image.  ### How it Works  Select an image and specify direction and scale. The API extends the canvas in that direction and generates new content that naturally continues the scene, maintaining style and coherence.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original image generation task      - &#x60;imageNo&#x60; - Image number to extend (0, 1, 2, or 3)      - &#x60;direction&#x60; - Extension direction: 0&#x3D;Down, 1&#x3D;Right, 2&#x3D;Up, 3&#x3D;Left      - &#x60;scale&#x60; - Extension scale ratio (1.1 to 3.0, e.g., 1.5 &#x3D; 50% larger in that direction)      - &#x60;remixPrompt&#x60; - Optional prompt to guide the extended content (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The extended images (4 variations) will be sent to your callback URL when complete (typically 90-120 seconds).  ### Use Cases  - Create wider landscape compositions from square images      - Extend portraits to include more environmental context      - Add vertical space for text overlays or additional content      - Build panoramic views from single images      - Adjust aspect ratios for different platform requirements       ### Tips  - Use remixPrompt to specify what should appear in the extended area      - Scale 1.5 is a good starting point (50% extension)      - Higher scales (2.0-3.0) create more new content but may lose coherence      - Works directionally - use outpaint for all-direction expansion      - Can be applied multiple times in different directions
        /// </remarks>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1PanPostApiResponse"/>?&gt;</returns>
        Task<IApiV1PanPostApiResponse?> ApiV1PanPostOrDefaultAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Remix
        /// </summary>
        /// <remarks>
        /// ## Transform Images with New Prompts  Apply a new text prompt to an existing image, transforming it while maintaining aspects of the original composition. Controllable intensity for subtle or dramatic changes.  ### How it Works  Select an image and provide a new prompt. The API applies the new description to the existing image, creating variations that blend the original structure with the new concept. Intensity mode controls how strongly the new prompt is applied.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original image generation task      - &#x60;imageNo&#x60; - Image number to remix (0, 1, 2, or 3)      - &#x60;remixPrompt&#x60; - New prompt to apply to the image (1-8192 characters)      - &#x60;mode&#x60; - Remix intensity: 0&#x3D;Strong (significant transformation), 1&#x3D;Subtle (light transformation)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The remixed images (4 variations) will be sent to your callback URL when complete (typically 90-120 seconds).  ### Use Cases  - Change the style or mood of an existing image      - Apply different artistic directions to the same composition      - Modify time of day, weather, or season in scenes      - Transform realistic images to artistic styles (or vice versa)      - Iterate on concepts by applying different prompts       ### Tips  - Mode 0 (Strong) makes dramatic changes while keeping some structure      - Mode 1 (Subtle) makes gentle modifications, preserving more of the original      - Remix prompt completely replaces the original prompt      - Great for style transfer and conceptual variations      - Experiment with both modes to find the right balance
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1RemixPostApiResponse"/>&gt;</returns>
        Task<IApiV1RemixPostApiResponse> ApiV1RemixPostAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Remix
        /// </summary>
        /// <remarks>
        /// ## Transform Images with New Prompts  Apply a new text prompt to an existing image, transforming it while maintaining aspects of the original composition. Controllable intensity for subtle or dramatic changes.  ### How it Works  Select an image and provide a new prompt. The API applies the new description to the existing image, creating variations that blend the original structure with the new concept. Intensity mode controls how strongly the new prompt is applied.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original image generation task      - &#x60;imageNo&#x60; - Image number to remix (0, 1, 2, or 3)      - &#x60;remixPrompt&#x60; - New prompt to apply to the image (1-8192 characters)      - &#x60;mode&#x60; - Remix intensity: 0&#x3D;Strong (significant transformation), 1&#x3D;Subtle (light transformation)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The remixed images (4 variations) will be sent to your callback URL when complete (typically 90-120 seconds).  ### Use Cases  - Change the style or mood of an existing image      - Apply different artistic directions to the same composition      - Modify time of day, weather, or season in scenes      - Transform realistic images to artistic styles (or vice versa)      - Iterate on concepts by applying different prompts       ### Tips  - Mode 0 (Strong) makes dramatic changes while keeping some structure      - Mode 1 (Subtle) makes gentle modifications, preserving more of the original      - Remix prompt completely replaces the original prompt      - Great for style transfer and conceptual variations      - Experiment with both modes to find the right balance
        /// </remarks>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1RemixPostApiResponse"/>?&gt;</returns>
        Task<IApiV1RemixPostApiResponse?> ApiV1RemixPostOrDefaultAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Reroll
        /// </summary>
        /// <remarks>
        /// ## Re-execute Task with Same Parameters  Regenerate a new set of images using the exact same parameters as a previous task. This is equivalent to running the original request again with identical settings.  ### How it Works  Provide a previous task&#39;s job ID and the API will execute the same generation with the same prompt and parameters, producing 4 completely new variations.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the task to reroll       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a new task object with different &#x60;job_id&#x60;. The rerolled images (4 new variations) will be sent to your callback URL when complete (typically 60-90 seconds).  ### Use Cases  - Try the same prompt again if initial results didn&#39;t meet expectations      - Generate additional variations without retyping prompts      - Explore different random seeds for the same concept      - Create more options from successful prompts       ### Tips  - Reroll uses the exact same parameters as the original task      - Results will be completely different due to different random seeds      - Consider using variation endpoint instead if you want to build on a specific result      - You can reroll any completed task, even from previous sessions
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1RerollPostApiResponse"/>&gt;</returns>
        Task<IApiV1RerollPostApiResponse> ApiV1RerollPostAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Reroll
        /// </summary>
        /// <remarks>
        /// ## Re-execute Task with Same Parameters  Regenerate a new set of images using the exact same parameters as a previous task. This is equivalent to running the original request again with identical settings.  ### How it Works  Provide a previous task&#39;s job ID and the API will execute the same generation with the same prompt and parameters, producing 4 completely new variations.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the task to reroll       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a new task object with different &#x60;job_id&#x60;. The rerolled images (4 new variations) will be sent to your callback URL when complete (typically 60-90 seconds).  ### Use Cases  - Try the same prompt again if initial results didn&#39;t meet expectations      - Generate additional variations without retyping prompts      - Explore different random seeds for the same concept      - Create more options from successful prompts       ### Tips  - Reroll uses the exact same parameters as the original task      - Results will be completely different due to different random seeds      - Consider using variation endpoint instead if you want to build on a specific result      - You can reroll any completed task, even from previous sessions
        /// </remarks>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1RerollPostApiResponse"/>?&gt;</returns>
        Task<IApiV1RerollPostApiResponse?> ApiV1RerollPostOrDefaultAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Shorten
        /// </summary>
        /// <remarks>
        /// ## Simplify Prompts to Essential Elements  Analyze a long or complex prompt and reduce it to its most essential and impactful elements, maintaining effectiveness while improving clarity.  ### How it Works  Submit a lengthy prompt and the API analyzes it using AI, identifying the most important elements and removing redundancy. Returns multiple shortened variations.  ### Required Parameters  - &#x60;prompt&#x60; - The text prompt to simplify (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The shortened prompt variations will be sent to your callback URL when complete (typically 20-40 seconds).  ### Use Cases  - Optimize overly verbose prompts for better results      - Learn which prompt elements are most impactful      - Reduce token usage in prompt-based workflows      - Clean up accumulated prompt modifications      - Simplify complex prompts for better model understanding       ### Tips  - Particularly useful for prompts over 100 words      - The AI preserves key descriptive elements while removing filler      - Multiple variations help you choose the best simplified version      - Test both original and shortened prompts to compare results      - Great for learning concise prompt writing techniques
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1ShortenPostApiResponse"/>&gt;</returns>
        Task<IApiV1ShortenPostApiResponse> ApiV1ShortenPostAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Shorten
        /// </summary>
        /// <remarks>
        /// ## Simplify Prompts to Essential Elements  Analyze a long or complex prompt and reduce it to its most essential and impactful elements, maintaining effectiveness while improving clarity.  ### How it Works  Submit a lengthy prompt and the API analyzes it using AI, identifying the most important elements and removing redundancy. Returns multiple shortened variations.  ### Required Parameters  - &#x60;prompt&#x60; - The text prompt to simplify (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The shortened prompt variations will be sent to your callback URL when complete (typically 20-40 seconds).  ### Use Cases  - Optimize overly verbose prompts for better results      - Learn which prompt elements are most impactful      - Reduce token usage in prompt-based workflows      - Clean up accumulated prompt modifications      - Simplify complex prompts for better model understanding       ### Tips  - Particularly useful for prompts over 100 words      - The AI preserves key descriptive elements while removing filler      - Multiple variations help you choose the best simplified version      - Test both original and shortened prompts to compare results      - Great for learning concise prompt writing techniques
        /// </remarks>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1ShortenPostApiResponse"/>?&gt;</returns>
        Task<IApiV1ShortenPostApiResponse?> ApiV1ShortenPostOrDefaultAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Upscale
        /// </summary>
        /// <remarks>
        /// ## Enhance Image Resolution and Quality  Upscale and enhance one of your generated images to higher resolution with AI-powered quality improvement. Produces a single high-resolution version of the selected image.  ### How it Works  Select one image from a generation task and choose upscaling type. The API processes the image to increase resolution while adding detail and clarity based on the selected upscaling mode.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original image generation task      - &#x60;imageNo&#x60; - Image number to upscale (0, 1, 2, or 3)      - &#x60;type&#x60; - Upscaling type: 0&#x3D;Subtle (conservative enhancement), 1&#x3D;Creative (adds detail and interpretation)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The upscaled image (single high-resolution output) will be sent to your callback URL when complete (typically 90-120 seconds).  ### Use Cases  - Prepare images for print or high-resolution displays      - Enhance selected variations for final delivery      - Create detailed versions for client presentations      - Generate production-ready assets from generations       ### Tips  - Type 0 (Subtle) is safer for preserving exact details      - Type 1 (Creative) works well for artistic images where added interpretation is acceptable      - Upscaling is typically the final step after selecting your preferred variation      - Output resolution is significantly higher than the original 4-image grid
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1UpscalePostApiResponse"/>&gt;</returns>
        Task<IApiV1UpscalePostApiResponse> ApiV1UpscalePostAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Upscale
        /// </summary>
        /// <remarks>
        /// ## Enhance Image Resolution and Quality  Upscale and enhance one of your generated images to higher resolution with AI-powered quality improvement. Produces a single high-resolution version of the selected image.  ### How it Works  Select one image from a generation task and choose upscaling type. The API processes the image to increase resolution while adding detail and clarity based on the selected upscaling mode.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original image generation task      - &#x60;imageNo&#x60; - Image number to upscale (0, 1, 2, or 3)      - &#x60;type&#x60; - Upscaling type: 0&#x3D;Subtle (conservative enhancement), 1&#x3D;Creative (adds detail and interpretation)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The upscaled image (single high-resolution output) will be sent to your callback URL when complete (typically 90-120 seconds).  ### Use Cases  - Prepare images for print or high-resolution displays      - Enhance selected variations for final delivery      - Create detailed versions for client presentations      - Generate production-ready assets from generations       ### Tips  - Type 0 (Subtle) is safer for preserving exact details      - Type 1 (Creative) works well for artistic images where added interpretation is acceptable      - Upscaling is typically the final step after selecting your preferred variation      - Output resolution is significantly higher than the original 4-image grid
        /// </remarks>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1UpscalePostApiResponse"/>?&gt;</returns>
        Task<IApiV1UpscalePostApiResponse?> ApiV1UpscalePostOrDefaultAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Variation
        /// </summary>
        /// <remarks>
        /// ## Create Controlled Variations of Existing Images  Generate new variations of a specific image from a previous generation task with controllable transformation intensity. Perfect for exploring different interpretations while maintaining the core composition.  ### How it Works  Select one of the 4 generated images from a diffusion task and create variations with either subtle or strong intensity. The API generates 4 new variations based on your selected image and intensity setting.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original image generation task      - &#x60;imageNo&#x60; - Image number to vary (0, 1, 2, or 3)      - &#x60;type&#x60; - Variation intensity: 0&#x3D;Subtle (minor changes), 1&#x3D;Strong (major changes)      - &#x60;remixPrompt&#x60; - Optional additional prompt for guided variation (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a new task object with &#x60;job_id&#x60;. The 4 variation images will be sent to your callback URL when processing completes (typically 60-90 seconds).  ### Use Cases  - Explore different interpretations of a successful generation      - Fine-tune specific aspects of an image      - Create multiple versions for A/B testing      - Generate variations for client review      - Remix images with additional prompt guidance       ### Tips  - Use type&#x3D;0 (subtle) for minor refinements, type&#x3D;1 (strong) for significant changes      - Add remixPrompt to guide the variation in a specific direction      - The original composition and structure are generally preserved      - Can chain variations: create variations of variations for iterative refinement
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1VariationPostApiResponse"/>&gt;</returns>
        Task<IApiV1VariationPostApiResponse> ApiV1VariationPostAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Variation
        /// </summary>
        /// <remarks>
        /// ## Create Controlled Variations of Existing Images  Generate new variations of a specific image from a previous generation task with controllable transformation intensity. Perfect for exploring different interpretations while maintaining the core composition.  ### How it Works  Select one of the 4 generated images from a diffusion task and create variations with either subtle or strong intensity. The API generates 4 new variations based on your selected image and intensity setting.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original image generation task      - &#x60;imageNo&#x60; - Image number to vary (0, 1, 2, or 3)      - &#x60;type&#x60; - Variation intensity: 0&#x3D;Subtle (minor changes), 1&#x3D;Strong (major changes)      - &#x60;remixPrompt&#x60; - Optional additional prompt for guided variation (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a new task object with &#x60;job_id&#x60;. The 4 variation images will be sent to your callback URL when processing completes (typically 60-90 seconds).  ### Use Cases  - Explore different interpretations of a successful generation      - Fine-tune specific aspects of an image      - Create multiple versions for A/B testing      - Generate variations for client review      - Remix images with additional prompt guidance       ### Tips  - Use type&#x3D;0 (subtle) for minor refinements, type&#x3D;1 (strong) for significant changes      - Add remixPrompt to guide the variation in a specific direction      - The original composition and structure are generally preserved      - Can chain variations: create variations of variations for iterative refinement
        /// </remarks>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1VariationPostApiResponse"/>?&gt;</returns>
        Task<IApiV1VariationPostApiResponse?> ApiV1VariationPostOrDefaultAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IApiV1BlendPostApiResponse"/>
    /// </summary>
    public interface IApiV1BlendPostApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.TaskResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IApiV1DescribePostApiResponse"/>
    /// </summary>
    public interface IApiV1DescribePostApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.TaskResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IApiV1DiffusionPostApiResponse"/>
    /// </summary>
    public interface IApiV1DiffusionPostApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ApiV1DiffusionPost200Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IApiV1EditPostApiResponse"/>
    /// </summary>
    public interface IApiV1EditPostApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ApiV1EditPost200Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IApiV1InpaintPostApiResponse"/>
    /// </summary>
    public interface IApiV1InpaintPostApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.TaskResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IApiV1OutpaintPostApiResponse"/>
    /// </summary>
    public interface IApiV1OutpaintPostApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.TaskResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IApiV1PanPostApiResponse"/>
    /// </summary>
    public interface IApiV1PanPostApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ApiV1PanPost200Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IApiV1RemixPostApiResponse"/>
    /// </summary>
    public interface IApiV1RemixPostApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.TaskResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IApiV1RerollPostApiResponse"/>
    /// </summary>
    public interface IApiV1RerollPostApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.TaskResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IApiV1ShortenPostApiResponse"/>
    /// </summary>
    public interface IApiV1ShortenPostApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.TaskResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IApiV1UpscalePostApiResponse"/>
    /// </summary>
    public interface IApiV1UpscalePostApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.TaskResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IApiV1VariationPostApiResponse"/>
    /// </summary>
    public interface IApiV1VariationPostApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.TaskResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class ImageApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnApiV1BlendPost;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorApiV1BlendPost;

        internal void ExecuteOnApiV1BlendPost(ImageApi.ApiV1BlendPostApiResponse apiResponse)
        {
            OnApiV1BlendPost?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorApiV1BlendPost(Exception exception)
        {
            OnErrorApiV1BlendPost?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnApiV1DescribePost;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorApiV1DescribePost;

        internal void ExecuteOnApiV1DescribePost(ImageApi.ApiV1DescribePostApiResponse apiResponse)
        {
            OnApiV1DescribePost?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorApiV1DescribePost(Exception exception)
        {
            OnErrorApiV1DescribePost?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnApiV1DiffusionPost;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorApiV1DiffusionPost;

        internal void ExecuteOnApiV1DiffusionPost(ImageApi.ApiV1DiffusionPostApiResponse apiResponse)
        {
            OnApiV1DiffusionPost?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorApiV1DiffusionPost(Exception exception)
        {
            OnErrorApiV1DiffusionPost?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnApiV1EditPost;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorApiV1EditPost;

        internal void ExecuteOnApiV1EditPost(ImageApi.ApiV1EditPostApiResponse apiResponse)
        {
            OnApiV1EditPost?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorApiV1EditPost(Exception exception)
        {
            OnErrorApiV1EditPost?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnApiV1InpaintPost;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorApiV1InpaintPost;

        internal void ExecuteOnApiV1InpaintPost(ImageApi.ApiV1InpaintPostApiResponse apiResponse)
        {
            OnApiV1InpaintPost?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorApiV1InpaintPost(Exception exception)
        {
            OnErrorApiV1InpaintPost?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnApiV1OutpaintPost;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorApiV1OutpaintPost;

        internal void ExecuteOnApiV1OutpaintPost(ImageApi.ApiV1OutpaintPostApiResponse apiResponse)
        {
            OnApiV1OutpaintPost?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorApiV1OutpaintPost(Exception exception)
        {
            OnErrorApiV1OutpaintPost?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnApiV1PanPost;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorApiV1PanPost;

        internal void ExecuteOnApiV1PanPost(ImageApi.ApiV1PanPostApiResponse apiResponse)
        {
            OnApiV1PanPost?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorApiV1PanPost(Exception exception)
        {
            OnErrorApiV1PanPost?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnApiV1RemixPost;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorApiV1RemixPost;

        internal void ExecuteOnApiV1RemixPost(ImageApi.ApiV1RemixPostApiResponse apiResponse)
        {
            OnApiV1RemixPost?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorApiV1RemixPost(Exception exception)
        {
            OnErrorApiV1RemixPost?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnApiV1RerollPost;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorApiV1RerollPost;

        internal void ExecuteOnApiV1RerollPost(ImageApi.ApiV1RerollPostApiResponse apiResponse)
        {
            OnApiV1RerollPost?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorApiV1RerollPost(Exception exception)
        {
            OnErrorApiV1RerollPost?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnApiV1ShortenPost;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorApiV1ShortenPost;

        internal void ExecuteOnApiV1ShortenPost(ImageApi.ApiV1ShortenPostApiResponse apiResponse)
        {
            OnApiV1ShortenPost?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorApiV1ShortenPost(Exception exception)
        {
            OnErrorApiV1ShortenPost?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnApiV1UpscalePost;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorApiV1UpscalePost;

        internal void ExecuteOnApiV1UpscalePost(ImageApi.ApiV1UpscalePostApiResponse apiResponse)
        {
            OnApiV1UpscalePost?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorApiV1UpscalePost(Exception exception)
        {
            OnErrorApiV1UpscalePost?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnApiV1VariationPost;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorApiV1VariationPost;

        internal void ExecuteOnApiV1VariationPost(ImageApi.ApiV1VariationPostApiResponse apiResponse)
        {
            OnApiV1VariationPost?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorApiV1VariationPost(Exception exception)
        {
            OnErrorApiV1VariationPost?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class ImageApi : IImageApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<ImageApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public ImageApiEvents Events { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ImageApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ImageApi(ILogger<ImageApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, ImageApiEvents imageApiEvents)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<ImageApi>();
            HttpClient = httpClient;
            Events = imageApiEvents;
        }

        partial void FormatApiV1BlendPost(ref Option<string> xApiKey, ref Option<string> body);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        private void ValidateApiV1BlendPost(Option<string> xApiKey, Option<string> body)
        {
            if (xApiKey.IsSet && xApiKey.Value == null)
                throw new ArgumentNullException(nameof(xApiKey));

            if (body.IsSet && body.Value == null)
                throw new ArgumentNullException(nameof(body));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void AfterApiV1BlendPostDefaultImplementation(IApiV1BlendPostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<string> body)
        {
            bool suppressDefaultLog = false;
            AfterApiV1BlendPost(ref suppressDefaultLog, apiResponseLocalVar, xApiKey, body);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void AfterApiV1BlendPost(ref bool suppressDefaultLog, IApiV1BlendPostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<string> body);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void OnErrorApiV1BlendPostDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<string> body)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorApiV1BlendPost(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, xApiKey, body);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void OnErrorApiV1BlendPost(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<string> body);

        /// <summary>
        /// Blend ## Combine Multiple Images into Unified Creation  Seamlessly blend 2-5 images together to create a single unique image that combines elements, styles, and concepts from all source images.  ### How it Works  Upload 2-5 image URLs and specify an aspect ratio. The API analyzes all images and creates a cohesive blend that merges their visual elements, colors, styles, and concepts.  ### Required Parameters  - &#x60;imgUrls&#x60; - Array of 2-5 image URLs to blend      - &#x60;aspect_ratio&#x60; - Output aspect ratio: \&quot;2:3\&quot; (portrait), \&quot;1:1\&quot; (square), or \&quot;3:2\&quot; (landscape)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The blended images (4 variations) will be sent to your callback URL when complete (typically 60-90 seconds).  ### Use Cases  - Combine style references for unique visual concepts      - Merge product photos with artistic styles      - Create hybrid concepts from multiple references      - Blend textures and patterns for design work      - Mix character designs or architectural styles       ### Tips  - Works best with 2-3 images; more images create more abstract results      - All source images should be publicly accessible URLs      - The blend is conceptual, not a simple overlay      - Consider the aspect ratio based on your intended use      - Experiment with different image composition, color palettes, or subject matter for varied results.
        /// </summary>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1BlendPostApiResponse"/>&gt;</returns>
        public async Task<IApiV1BlendPostApiResponse?> ApiV1BlendPostOrDefaultAsync(Option<string> xApiKey = default, Option<string> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ApiV1BlendPostAsync(xApiKey, body, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Blend ## Combine Multiple Images into Unified Creation  Seamlessly blend 2-5 images together to create a single unique image that combines elements, styles, and concepts from all source images.  ### How it Works  Upload 2-5 image URLs and specify an aspect ratio. The API analyzes all images and creates a cohesive blend that merges their visual elements, colors, styles, and concepts.  ### Required Parameters  - &#x60;imgUrls&#x60; - Array of 2-5 image URLs to blend      - &#x60;aspect_ratio&#x60; - Output aspect ratio: \&quot;2:3\&quot; (portrait), \&quot;1:1\&quot; (square), or \&quot;3:2\&quot; (landscape)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The blended images (4 variations) will be sent to your callback URL when complete (typically 60-90 seconds).  ### Use Cases  - Combine style references for unique visual concepts      - Merge product photos with artistic styles      - Create hybrid concepts from multiple references      - Blend textures and patterns for design work      - Mix character designs or architectural styles       ### Tips  - Works best with 2-3 images; more images create more abstract results      - All source images should be publicly accessible URLs      - The blend is conceptual, not a simple overlay      - Consider the aspect ratio based on your intended use      - Experiment with different image composition, color palettes, or subject matter for varied results.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1BlendPostApiResponse"/>&gt;</returns>
        public async Task<IApiV1BlendPostApiResponse> ApiV1BlendPostAsync(Option<string> xApiKey = default, Option<string> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateApiV1BlendPost(xApiKey, body);

                FormatApiV1BlendPost(ref xApiKey, ref body);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/blend"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/blend");

                    if (xApiKey.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("x-api-key", ClientUtils.ParameterToString(xApiKey.Value));

                    if (body.IsSet)
                        httpRequestMessageLocalVar.Content = (body.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(body.Value, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ApiV1BlendPostApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ApiV1BlendPostApiResponse>();
                        ApiV1BlendPostApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/blend", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterApiV1BlendPostDefaultImplementation(apiResponseLocalVar, xApiKey, body);

                        Events.ExecuteOnApiV1BlendPost(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorApiV1BlendPostDefaultImplementation(e, "/api/v1/blend", uriBuilderLocalVar.Path, xApiKey, body);
                Events.ExecuteOnErrorApiV1BlendPost(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ApiV1BlendPostApiResponse"/>
        /// </summary>
        public partial class ApiV1BlendPostApiResponse : Org.OpenAPITools.Client.ApiResponse, IApiV1BlendPostApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ApiV1BlendPostApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ApiV1BlendPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1BlendPostApiResponse(ILogger<ApiV1BlendPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ApiV1BlendPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1BlendPostApiResponse(ILogger<ApiV1BlendPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.TaskResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.TaskResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.TaskResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatApiV1DescribePost(ref Option<string> xApiKey, ref Option<Object> body);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        private void ValidateApiV1DescribePost(Option<string> xApiKey, Option<Object> body)
        {
            if (xApiKey.IsSet && xApiKey.Value == null)
                throw new ArgumentNullException(nameof(xApiKey));

            if (body.IsSet && body.Value == null)
                throw new ArgumentNullException(nameof(body));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void AfterApiV1DescribePostDefaultImplementation(IApiV1DescribePostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<Object> body)
        {
            bool suppressDefaultLog = false;
            AfterApiV1DescribePost(ref suppressDefaultLog, apiResponseLocalVar, xApiKey, body);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void AfterApiV1DescribePost(ref bool suppressDefaultLog, IApiV1DescribePostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<Object> body);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void OnErrorApiV1DescribePostDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<Object> body)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorApiV1DescribePost(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, xApiKey, body);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void OnErrorApiV1DescribePost(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<Object> body);

        /// <summary>
        /// Describe ## Generate Detailed Text Descriptions from Images  Analyze an image and generate detailed text descriptions that can be used as prompts for image generation. Perfect for reverse-engineering images or creating prompt variations.  ### How it Works  Provide an image URL and the API analyzes the image using AI, generating 4 different text descriptions that capture the image&#39;s content, style, mood, and composition.  ### Required Parameters  - &#x60;imgUrl&#x60; - Public URL of the image to analyze and describe       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The generated descriptions (typically 4 variations) will be sent to your callback URL when complete (typically 30-60 seconds).  ### Use Cases  - Reverse-engineer successful images to understand prompt styles      - Generate prompt variations from reference images      - Create training data for prompt engineering      - Document image libraries with AI-generated descriptions      - Learn effective prompt writing by analyzing AI descriptions       ### Tips  - Image URL must be publicly accessible      - Descriptions can be used directly as prompts for diffusion endpoint      - Each description offers a different perspective/focus on the image      - Useful for building prompt libraries from visual references      - Combine with your own modifications for customized prompts
        /// </summary>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1DescribePostApiResponse"/>&gt;</returns>
        public async Task<IApiV1DescribePostApiResponse?> ApiV1DescribePostOrDefaultAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ApiV1DescribePostAsync(xApiKey, body, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Describe ## Generate Detailed Text Descriptions from Images  Analyze an image and generate detailed text descriptions that can be used as prompts for image generation. Perfect for reverse-engineering images or creating prompt variations.  ### How it Works  Provide an image URL and the API analyzes the image using AI, generating 4 different text descriptions that capture the image&#39;s content, style, mood, and composition.  ### Required Parameters  - &#x60;imgUrl&#x60; - Public URL of the image to analyze and describe       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The generated descriptions (typically 4 variations) will be sent to your callback URL when complete (typically 30-60 seconds).  ### Use Cases  - Reverse-engineer successful images to understand prompt styles      - Generate prompt variations from reference images      - Create training data for prompt engineering      - Document image libraries with AI-generated descriptions      - Learn effective prompt writing by analyzing AI descriptions       ### Tips  - Image URL must be publicly accessible      - Descriptions can be used directly as prompts for diffusion endpoint      - Each description offers a different perspective/focus on the image      - Useful for building prompt libraries from visual references      - Combine with your own modifications for customized prompts
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1DescribePostApiResponse"/>&gt;</returns>
        public async Task<IApiV1DescribePostApiResponse> ApiV1DescribePostAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateApiV1DescribePost(xApiKey, body);

                FormatApiV1DescribePost(ref xApiKey, ref body);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/describe"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/describe");

                    if (xApiKey.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("x-api-key", ClientUtils.ParameterToString(xApiKey.Value));

                    if (body.IsSet)
                        httpRequestMessageLocalVar.Content = (body.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(body.Value, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ApiV1DescribePostApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ApiV1DescribePostApiResponse>();
                        ApiV1DescribePostApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/describe", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterApiV1DescribePostDefaultImplementation(apiResponseLocalVar, xApiKey, body);

                        Events.ExecuteOnApiV1DescribePost(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorApiV1DescribePostDefaultImplementation(e, "/api/v1/describe", uriBuilderLocalVar.Path, xApiKey, body);
                Events.ExecuteOnErrorApiV1DescribePost(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ApiV1DescribePostApiResponse"/>
        /// </summary>
        public partial class ApiV1DescribePostApiResponse : Org.OpenAPITools.Client.ApiResponse, IApiV1DescribePostApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ApiV1DescribePostApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ApiV1DescribePostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1DescribePostApiResponse(ILogger<ApiV1DescribePostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ApiV1DescribePostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1DescribePostApiResponse(ILogger<ApiV1DescribePostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.TaskResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.TaskResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.TaskResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatApiV1DiffusionPost(ref Option<string> xApiKey, ref Option<Object> body);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        private void ValidateApiV1DiffusionPost(Option<string> xApiKey, Option<Object> body)
        {
            if (xApiKey.IsSet && xApiKey.Value == null)
                throw new ArgumentNullException(nameof(xApiKey));

            if (body.IsSet && body.Value == null)
                throw new ArgumentNullException(nameof(body));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void AfterApiV1DiffusionPostDefaultImplementation(IApiV1DiffusionPostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<Object> body)
        {
            bool suppressDefaultLog = false;
            AfterApiV1DiffusionPost(ref suppressDefaultLog, apiResponseLocalVar, xApiKey, body);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void AfterApiV1DiffusionPost(ref bool suppressDefaultLog, IApiV1DiffusionPostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<Object> body);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void OnErrorApiV1DiffusionPostDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<Object> body)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorApiV1DiffusionPost(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, xApiKey, body);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void OnErrorApiV1DiffusionPost(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<Object> body);

        /// <summary>
        /// Diffusion ## Generate Image from Text Prompt (Diffusion)  Creates AI-generated images from text descriptions using Midjourney&#39;s diffusion model. This endpoint processes your prompt asynchronously and delivers the generated image to your specified callback URL.  ### How It Works  Submit a text prompt describing the image you want to create. The API processes your request using Midjourney&#39;s AI model and sends the generated image result to your callback URL when complete. Processing typically takes 30-90 seconds depending on complexity and queue length.  ### Required Parameters  - **&#x60;text&#x60;** (string, required) - Your image description prompt          - Example: &#x60;\&quot;A beautiful sunset over the snow mountains\&quot;&#x60;              - Supports Midjourney parameters like &#x60;- -v 7&#x60; (model version), &#x60;- -draft&#x60; (draft mode), &#x60;- -ar 16:9&#x60; (aspect ratio)              - Be specific and descriptive for best results          - **&#x60;callback&#x60;** (string, required) - HTTPS webhook URL to receive the result          - Must be publicly accessible and accept POST requests              - Example: &#x60;\&quot;https://your-domain.com/webhook/image-result\&quot;&#x60;              - The API will send the generated image data to this URL when processing completes           ### Authentication  Requires a valid API key in the &#x60;x-api-key&#x60; header. Store your API key securely in environment variables and never expose it in client-side code.  ### Response  Returns immediately with a task ID and status. The actual generated image will be delivered to your callback URL asynchronously once processing completes.  ### Common Use Cases  - Generate marketing visuals and social media content      - Create concept art and design mockups      - Produce unique illustrations for articles and presentations      - Prototype visual ideas before commissioning custom artwork      - Build AI-powered image generation features into your applications       ### Tips for Success  - **Be specific:** Detailed prompts produce better results (e.g., \&quot;photorealistic mountain landscape at golden hour\&quot; vs \&quot;mountains\&quot;)      - **Use Midjourney parameters:** Add &#x60;- -v 7&#x60; for the latest model version, &#x60;- -ar 16:9&#x60; for widescreen format      - **Test your callback:** Ensure your webhook endpoint is accessible and can handle POST requests before submitting jobs      - **Handle async responses:** Implement proper webhook handling to receive and process results      - **Monitor task status:** Use the \&quot;Get task response\&quot; endpoint if you need to check job status manually       ### Related Endpoints  - **Get task response** - Check the status of your generation task      - **Variation** - Create variations of a generated image      - **Upscale** - Enhance the resolution of generated images      - **Reroll** - Generate alternative versions with the same prompt
        /// </summary>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1DiffusionPostApiResponse"/>&gt;</returns>
        public async Task<IApiV1DiffusionPostApiResponse?> ApiV1DiffusionPostOrDefaultAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ApiV1DiffusionPostAsync(xApiKey, body, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Diffusion ## Generate Image from Text Prompt (Diffusion)  Creates AI-generated images from text descriptions using Midjourney&#39;s diffusion model. This endpoint processes your prompt asynchronously and delivers the generated image to your specified callback URL.  ### How It Works  Submit a text prompt describing the image you want to create. The API processes your request using Midjourney&#39;s AI model and sends the generated image result to your callback URL when complete. Processing typically takes 30-90 seconds depending on complexity and queue length.  ### Required Parameters  - **&#x60;text&#x60;** (string, required) - Your image description prompt          - Example: &#x60;\&quot;A beautiful sunset over the snow mountains\&quot;&#x60;              - Supports Midjourney parameters like &#x60;- -v 7&#x60; (model version), &#x60;- -draft&#x60; (draft mode), &#x60;- -ar 16:9&#x60; (aspect ratio)              - Be specific and descriptive for best results          - **&#x60;callback&#x60;** (string, required) - HTTPS webhook URL to receive the result          - Must be publicly accessible and accept POST requests              - Example: &#x60;\&quot;https://your-domain.com/webhook/image-result\&quot;&#x60;              - The API will send the generated image data to this URL when processing completes           ### Authentication  Requires a valid API key in the &#x60;x-api-key&#x60; header. Store your API key securely in environment variables and never expose it in client-side code.  ### Response  Returns immediately with a task ID and status. The actual generated image will be delivered to your callback URL asynchronously once processing completes.  ### Common Use Cases  - Generate marketing visuals and social media content      - Create concept art and design mockups      - Produce unique illustrations for articles and presentations      - Prototype visual ideas before commissioning custom artwork      - Build AI-powered image generation features into your applications       ### Tips for Success  - **Be specific:** Detailed prompts produce better results (e.g., \&quot;photorealistic mountain landscape at golden hour\&quot; vs \&quot;mountains\&quot;)      - **Use Midjourney parameters:** Add &#x60;- -v 7&#x60; for the latest model version, &#x60;- -ar 16:9&#x60; for widescreen format      - **Test your callback:** Ensure your webhook endpoint is accessible and can handle POST requests before submitting jobs      - **Handle async responses:** Implement proper webhook handling to receive and process results      - **Monitor task status:** Use the \&quot;Get task response\&quot; endpoint if you need to check job status manually       ### Related Endpoints  - **Get task response** - Check the status of your generation task      - **Variation** - Create variations of a generated image      - **Upscale** - Enhance the resolution of generated images      - **Reroll** - Generate alternative versions with the same prompt
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1DiffusionPostApiResponse"/>&gt;</returns>
        public async Task<IApiV1DiffusionPostApiResponse> ApiV1DiffusionPostAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateApiV1DiffusionPost(xApiKey, body);

                FormatApiV1DiffusionPost(ref xApiKey, ref body);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/diffusion"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/diffusion");

                    if (xApiKey.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("x-api-key", ClientUtils.ParameterToString(xApiKey.Value));

                    if (body.IsSet)
                        httpRequestMessageLocalVar.Content = (body.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(body.Value, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ApiV1DiffusionPostApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ApiV1DiffusionPostApiResponse>();
                        ApiV1DiffusionPostApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/diffusion", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterApiV1DiffusionPostDefaultImplementation(apiResponseLocalVar, xApiKey, body);

                        Events.ExecuteOnApiV1DiffusionPost(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorApiV1DiffusionPostDefaultImplementation(e, "/api/v1/diffusion", uriBuilderLocalVar.Path, xApiKey, body);
                Events.ExecuteOnErrorApiV1DiffusionPost(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ApiV1DiffusionPostApiResponse"/>
        /// </summary>
        public partial class ApiV1DiffusionPostApiResponse : Org.OpenAPITools.Client.ApiResponse, IApiV1DiffusionPostApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ApiV1DiffusionPostApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ApiV1DiffusionPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1DiffusionPostApiResponse(ILogger<ApiV1DiffusionPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ApiV1DiffusionPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1DiffusionPostApiResponse(ILogger<ApiV1DiffusionPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ApiV1DiffusionPost200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ApiV1DiffusionPost200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ApiV1DiffusionPost200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatApiV1EditPost(ref Option<string> xApiKey, ref Option<Object> body);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        private void ValidateApiV1EditPost(Option<string> xApiKey, Option<Object> body)
        {
            if (xApiKey.IsSet && xApiKey.Value == null)
                throw new ArgumentNullException(nameof(xApiKey));

            if (body.IsSet && body.Value == null)
                throw new ArgumentNullException(nameof(body));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void AfterApiV1EditPostDefaultImplementation(IApiV1EditPostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<Object> body)
        {
            bool suppressDefaultLog = false;
            AfterApiV1EditPost(ref suppressDefaultLog, apiResponseLocalVar, xApiKey, body);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void AfterApiV1EditPost(ref bool suppressDefaultLog, IApiV1EditPostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<Object> body);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void OnErrorApiV1EditPostDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<Object> body)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorApiV1EditPost(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, xApiKey, body);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void OnErrorApiV1EditPost(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<Object> body);

        /// <summary>
        /// Edit ## Edit Images with Custom Canvas and Positioning  Perform advanced image editing by placing an image on a custom canvas with precise positioning control. Enables complex edits, extensions, and compositions.  ### How it Works  Place a selected image on a custom-sized canvas at specified coordinates. The API fills empty canvas areas with generated content based on your prompt, allowing for flexible composition and extensions.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original image generation task      - &#x60;imageNo&#x60; - Image number to edit (0, 1, 2, or 3)      - &#x60;canvas&#x60; - Target canvas dimensions:          - &#x60;width&#x60; - Canvas width in pixels              - &#x60;height&#x60; - Canvas height in pixels          - &#x60;imgPos&#x60; - Image position on canvas:          - &#x60;width&#x60; - Image width in pixels              - &#x60;height&#x60; - Image height in pixels              - &#x60;x&#x60; - Horizontal offset from canvas top-left              - &#x60;y&#x60; - Vertical offset from canvas top-left          - &#x60;remixPrompt&#x60; - Prompt for filling empty canvas areas (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The edited images (4 variations) will be sent to your callback URL when complete (typically 90-120 seconds).  ### Use Cases  - Create complex compositions with custom layouts      - Extend images asymmetrically in specific directions      - Place subjects in entirely new contexts      - Generate custom aspect ratios with filled backgrounds      - Build complex scenes by positioning and extending images       ### Tips  - Canvas dimensions define the final output size      - imgPos coordinates place your image within the canvas      - Empty canvas areas are generated based on remixPrompt      - More flexible than pan/outpaint for asymmetric extensions      - Useful for precise aspect ratio and positioning control
        /// </summary>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1EditPostApiResponse"/>&gt;</returns>
        public async Task<IApiV1EditPostApiResponse?> ApiV1EditPostOrDefaultAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ApiV1EditPostAsync(xApiKey, body, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Edit ## Edit Images with Custom Canvas and Positioning  Perform advanced image editing by placing an image on a custom canvas with precise positioning control. Enables complex edits, extensions, and compositions.  ### How it Works  Place a selected image on a custom-sized canvas at specified coordinates. The API fills empty canvas areas with generated content based on your prompt, allowing for flexible composition and extensions.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original image generation task      - &#x60;imageNo&#x60; - Image number to edit (0, 1, 2, or 3)      - &#x60;canvas&#x60; - Target canvas dimensions:          - &#x60;width&#x60; - Canvas width in pixels              - &#x60;height&#x60; - Canvas height in pixels          - &#x60;imgPos&#x60; - Image position on canvas:          - &#x60;width&#x60; - Image width in pixels              - &#x60;height&#x60; - Image height in pixels              - &#x60;x&#x60; - Horizontal offset from canvas top-left              - &#x60;y&#x60; - Vertical offset from canvas top-left          - &#x60;remixPrompt&#x60; - Prompt for filling empty canvas areas (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The edited images (4 variations) will be sent to your callback URL when complete (typically 90-120 seconds).  ### Use Cases  - Create complex compositions with custom layouts      - Extend images asymmetrically in specific directions      - Place subjects in entirely new contexts      - Generate custom aspect ratios with filled backgrounds      - Build complex scenes by positioning and extending images       ### Tips  - Canvas dimensions define the final output size      - imgPos coordinates place your image within the canvas      - Empty canvas areas are generated based on remixPrompt      - More flexible than pan/outpaint for asymmetric extensions      - Useful for precise aspect ratio and positioning control
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1EditPostApiResponse"/>&gt;</returns>
        public async Task<IApiV1EditPostApiResponse> ApiV1EditPostAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateApiV1EditPost(xApiKey, body);

                FormatApiV1EditPost(ref xApiKey, ref body);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/edit"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/edit");

                    if (xApiKey.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("x-api-key", ClientUtils.ParameterToString(xApiKey.Value));

                    if (body.IsSet)
                        httpRequestMessageLocalVar.Content = (body.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(body.Value, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ApiV1EditPostApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ApiV1EditPostApiResponse>();
                        ApiV1EditPostApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/edit", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterApiV1EditPostDefaultImplementation(apiResponseLocalVar, xApiKey, body);

                        Events.ExecuteOnApiV1EditPost(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorApiV1EditPostDefaultImplementation(e, "/api/v1/edit", uriBuilderLocalVar.Path, xApiKey, body);
                Events.ExecuteOnErrorApiV1EditPost(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ApiV1EditPostApiResponse"/>
        /// </summary>
        public partial class ApiV1EditPostApiResponse : Org.OpenAPITools.Client.ApiResponse, IApiV1EditPostApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ApiV1EditPostApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ApiV1EditPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1EditPostApiResponse(ILogger<ApiV1EditPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ApiV1EditPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1EditPostApiResponse(ILogger<ApiV1EditPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ApiV1EditPost200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ApiV1EditPost200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ApiV1EditPost200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatApiV1InpaintPost(ref Option<string> xApiKey, ref Option<Object> body);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        private void ValidateApiV1InpaintPost(Option<string> xApiKey, Option<Object> body)
        {
            if (xApiKey.IsSet && xApiKey.Value == null)
                throw new ArgumentNullException(nameof(xApiKey));

            if (body.IsSet && body.Value == null)
                throw new ArgumentNullException(nameof(body));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void AfterApiV1InpaintPostDefaultImplementation(IApiV1InpaintPostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<Object> body)
        {
            bool suppressDefaultLog = false;
            AfterApiV1InpaintPost(ref suppressDefaultLog, apiResponseLocalVar, xApiKey, body);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void AfterApiV1InpaintPost(ref bool suppressDefaultLog, IApiV1InpaintPostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<Object> body);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void OnErrorApiV1InpaintPostDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<Object> body)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorApiV1InpaintPost(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, xApiKey, body);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void OnErrorApiV1InpaintPost(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<Object> body);

        /// <summary>
        /// Inpaint ## Selectively Modify Image Regions with Masks  Repaint or modify specific regions within an existing image using mask-based editing. Target precise areas for changes while preserving the rest of the image.  ### How it Works  Select an image and define regions to modify using either polygon coordinates or a mask image URL. Optionally provide a prompt to guide what should appear in those regions. The API regenerates only the masked areas.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original image generation task      - &#x60;imageNo&#x60; - Image number to edit (0, 1, 2, or 3)      - &#x60;mask&#x60; - Regions to repaint (use either areas array or url):          - &#x60;areas&#x60; - Array of polygons with width, height, and points (XYXY coordinates)              - &#x60;url&#x60; - Black and white mask image URL (white areas will be repainted)          - &#x60;remixPrompt&#x60; - Optional prompt for the repaint area (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The inpainted images (4 variations) will be sent to your callback URL when complete (typically 90-120 seconds).  ### Use Cases  - Remove unwanted objects from images      - Replace specific elements while keeping surroundings      - Modify facial expressions or poses      - Change colors or textures in targeted areas      - Fix specific issues without regenerating entire image       ### Tips  - Polygon points format: \\[x1,y1, x2,y2, x3,y3, x4,y4\\] in clockwise order      - Mask images: white &#x3D; repaint, black &#x3D; keep original      - Use remixPrompt to specify what should replace masked content      - Smaller masks give more precise control      - Can apply multiple polygon areas in a single request
        /// </summary>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1InpaintPostApiResponse"/>&gt;</returns>
        public async Task<IApiV1InpaintPostApiResponse?> ApiV1InpaintPostOrDefaultAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ApiV1InpaintPostAsync(xApiKey, body, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Inpaint ## Selectively Modify Image Regions with Masks  Repaint or modify specific regions within an existing image using mask-based editing. Target precise areas for changes while preserving the rest of the image.  ### How it Works  Select an image and define regions to modify using either polygon coordinates or a mask image URL. Optionally provide a prompt to guide what should appear in those regions. The API regenerates only the masked areas.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original image generation task      - &#x60;imageNo&#x60; - Image number to edit (0, 1, 2, or 3)      - &#x60;mask&#x60; - Regions to repaint (use either areas array or url):          - &#x60;areas&#x60; - Array of polygons with width, height, and points (XYXY coordinates)              - &#x60;url&#x60; - Black and white mask image URL (white areas will be repainted)          - &#x60;remixPrompt&#x60; - Optional prompt for the repaint area (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The inpainted images (4 variations) will be sent to your callback URL when complete (typically 90-120 seconds).  ### Use Cases  - Remove unwanted objects from images      - Replace specific elements while keeping surroundings      - Modify facial expressions or poses      - Change colors or textures in targeted areas      - Fix specific issues without regenerating entire image       ### Tips  - Polygon points format: \\[x1,y1, x2,y2, x3,y3, x4,y4\\] in clockwise order      - Mask images: white &#x3D; repaint, black &#x3D; keep original      - Use remixPrompt to specify what should replace masked content      - Smaller masks give more precise control      - Can apply multiple polygon areas in a single request
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1InpaintPostApiResponse"/>&gt;</returns>
        public async Task<IApiV1InpaintPostApiResponse> ApiV1InpaintPostAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateApiV1InpaintPost(xApiKey, body);

                FormatApiV1InpaintPost(ref xApiKey, ref body);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/inpaint"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/inpaint");

                    if (xApiKey.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("x-api-key", ClientUtils.ParameterToString(xApiKey.Value));

                    if (body.IsSet)
                        httpRequestMessageLocalVar.Content = (body.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(body.Value, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ApiV1InpaintPostApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ApiV1InpaintPostApiResponse>();
                        ApiV1InpaintPostApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/inpaint", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterApiV1InpaintPostDefaultImplementation(apiResponseLocalVar, xApiKey, body);

                        Events.ExecuteOnApiV1InpaintPost(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorApiV1InpaintPostDefaultImplementation(e, "/api/v1/inpaint", uriBuilderLocalVar.Path, xApiKey, body);
                Events.ExecuteOnErrorApiV1InpaintPost(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ApiV1InpaintPostApiResponse"/>
        /// </summary>
        public partial class ApiV1InpaintPostApiResponse : Org.OpenAPITools.Client.ApiResponse, IApiV1InpaintPostApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ApiV1InpaintPostApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ApiV1InpaintPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1InpaintPostApiResponse(ILogger<ApiV1InpaintPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ApiV1InpaintPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1InpaintPostApiResponse(ILogger<ApiV1InpaintPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.TaskResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.TaskResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.TaskResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatApiV1OutpaintPost(ref Option<string> xApiKey, ref Option<Object> body);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        private void ValidateApiV1OutpaintPost(Option<string> xApiKey, Option<Object> body)
        {
            if (xApiKey.IsSet && xApiKey.Value == null)
                throw new ArgumentNullException(nameof(xApiKey));

            if (body.IsSet && body.Value == null)
                throw new ArgumentNullException(nameof(body));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void AfterApiV1OutpaintPostDefaultImplementation(IApiV1OutpaintPostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<Object> body)
        {
            bool suppressDefaultLog = false;
            AfterApiV1OutpaintPost(ref suppressDefaultLog, apiResponseLocalVar, xApiKey, body);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void AfterApiV1OutpaintPost(ref bool suppressDefaultLog, IApiV1OutpaintPostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<Object> body);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void OnErrorApiV1OutpaintPostDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<Object> body)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorApiV1OutpaintPost(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, xApiKey, body);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void OnErrorApiV1OutpaintPost(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<Object> body);

        /// <summary>
        /// Outpaint ## Expand Images in All Directions  Extend an image uniformly in all directions using intelligent outpainting. Creates a larger canvas while maintaining the original image at the center.  ### How it Works  Select an image and specify scale factor. The API expands the canvas uniformly in all directions and generates new content that naturally continues the scene on all sides.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original image generation task      - &#x60;imageNo&#x60; - Image number to expand (0, 1, 2, or 3)      - &#x60;scale&#x60; - Extension scale ratio (1.1 to 2.0, e.g., 1.5 &#x3D; 50% larger in all directions)      - &#x60;remixPrompt&#x60; - Optional prompt to guide the outpainted areas (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The outpainted images (4 variations) will be sent to your callback URL when complete (typically 90-120 seconds).  ### Use Cases  - Add environmental context around subject-focused images      - Create wider scenes from cropped compositions      - Extend backgrounds for design flexibility      - Generate variations with different surrounding content      - Prepare images for different aspect ratios       ### Tips  - Scale range 1.1-2.0 (outpaint is more conservative than pan)      - Use remixPrompt to describe desired surrounding content      - Great for adding context without losing the original subject      - Original image remains intact at center      - Compare with pan for directional control vs. uniform expansion
        /// </summary>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1OutpaintPostApiResponse"/>&gt;</returns>
        public async Task<IApiV1OutpaintPostApiResponse?> ApiV1OutpaintPostOrDefaultAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ApiV1OutpaintPostAsync(xApiKey, body, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Outpaint ## Expand Images in All Directions  Extend an image uniformly in all directions using intelligent outpainting. Creates a larger canvas while maintaining the original image at the center.  ### How it Works  Select an image and specify scale factor. The API expands the canvas uniformly in all directions and generates new content that naturally continues the scene on all sides.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original image generation task      - &#x60;imageNo&#x60; - Image number to expand (0, 1, 2, or 3)      - &#x60;scale&#x60; - Extension scale ratio (1.1 to 2.0, e.g., 1.5 &#x3D; 50% larger in all directions)      - &#x60;remixPrompt&#x60; - Optional prompt to guide the outpainted areas (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The outpainted images (4 variations) will be sent to your callback URL when complete (typically 90-120 seconds).  ### Use Cases  - Add environmental context around subject-focused images      - Create wider scenes from cropped compositions      - Extend backgrounds for design flexibility      - Generate variations with different surrounding content      - Prepare images for different aspect ratios       ### Tips  - Scale range 1.1-2.0 (outpaint is more conservative than pan)      - Use remixPrompt to describe desired surrounding content      - Great for adding context without losing the original subject      - Original image remains intact at center      - Compare with pan for directional control vs. uniform expansion
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1OutpaintPostApiResponse"/>&gt;</returns>
        public async Task<IApiV1OutpaintPostApiResponse> ApiV1OutpaintPostAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateApiV1OutpaintPost(xApiKey, body);

                FormatApiV1OutpaintPost(ref xApiKey, ref body);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/outpaint"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/outpaint");

                    if (xApiKey.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("x-api-key", ClientUtils.ParameterToString(xApiKey.Value));

                    if (body.IsSet)
                        httpRequestMessageLocalVar.Content = (body.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(body.Value, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ApiV1OutpaintPostApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ApiV1OutpaintPostApiResponse>();
                        ApiV1OutpaintPostApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/outpaint", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterApiV1OutpaintPostDefaultImplementation(apiResponseLocalVar, xApiKey, body);

                        Events.ExecuteOnApiV1OutpaintPost(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorApiV1OutpaintPostDefaultImplementation(e, "/api/v1/outpaint", uriBuilderLocalVar.Path, xApiKey, body);
                Events.ExecuteOnErrorApiV1OutpaintPost(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ApiV1OutpaintPostApiResponse"/>
        /// </summary>
        public partial class ApiV1OutpaintPostApiResponse : Org.OpenAPITools.Client.ApiResponse, IApiV1OutpaintPostApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ApiV1OutpaintPostApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ApiV1OutpaintPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1OutpaintPostApiResponse(ILogger<ApiV1OutpaintPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ApiV1OutpaintPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1OutpaintPostApiResponse(ILogger<ApiV1OutpaintPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.TaskResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.TaskResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.TaskResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatApiV1PanPost(ref Option<string> xApiKey, ref Option<Object> body);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        private void ValidateApiV1PanPost(Option<string> xApiKey, Option<Object> body)
        {
            if (xApiKey.IsSet && xApiKey.Value == null)
                throw new ArgumentNullException(nameof(xApiKey));

            if (body.IsSet && body.Value == null)
                throw new ArgumentNullException(nameof(body));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void AfterApiV1PanPostDefaultImplementation(IApiV1PanPostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<Object> body)
        {
            bool suppressDefaultLog = false;
            AfterApiV1PanPost(ref suppressDefaultLog, apiResponseLocalVar, xApiKey, body);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void AfterApiV1PanPost(ref bool suppressDefaultLog, IApiV1PanPostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<Object> body);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void OnErrorApiV1PanPostDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<Object> body)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorApiV1PanPost(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, xApiKey, body);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void OnErrorApiV1PanPost(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<Object> body);

        /// <summary>
        /// Pan ## Extend Images in Specific Direction  Expand an image in a single specified direction (up, down, left, or right) with precision scale control. Generates new content that seamlessly continues the original image.  ### How it Works  Select an image and specify direction and scale. The API extends the canvas in that direction and generates new content that naturally continues the scene, maintaining style and coherence.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original image generation task      - &#x60;imageNo&#x60; - Image number to extend (0, 1, 2, or 3)      - &#x60;direction&#x60; - Extension direction: 0&#x3D;Down, 1&#x3D;Right, 2&#x3D;Up, 3&#x3D;Left      - &#x60;scale&#x60; - Extension scale ratio (1.1 to 3.0, e.g., 1.5 &#x3D; 50% larger in that direction)      - &#x60;remixPrompt&#x60; - Optional prompt to guide the extended content (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The extended images (4 variations) will be sent to your callback URL when complete (typically 90-120 seconds).  ### Use Cases  - Create wider landscape compositions from square images      - Extend portraits to include more environmental context      - Add vertical space for text overlays or additional content      - Build panoramic views from single images      - Adjust aspect ratios for different platform requirements       ### Tips  - Use remixPrompt to specify what should appear in the extended area      - Scale 1.5 is a good starting point (50% extension)      - Higher scales (2.0-3.0) create more new content but may lose coherence      - Works directionally - use outpaint for all-direction expansion      - Can be applied multiple times in different directions
        /// </summary>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1PanPostApiResponse"/>&gt;</returns>
        public async Task<IApiV1PanPostApiResponse?> ApiV1PanPostOrDefaultAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ApiV1PanPostAsync(xApiKey, body, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Pan ## Extend Images in Specific Direction  Expand an image in a single specified direction (up, down, left, or right) with precision scale control. Generates new content that seamlessly continues the original image.  ### How it Works  Select an image and specify direction and scale. The API extends the canvas in that direction and generates new content that naturally continues the scene, maintaining style and coherence.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original image generation task      - &#x60;imageNo&#x60; - Image number to extend (0, 1, 2, or 3)      - &#x60;direction&#x60; - Extension direction: 0&#x3D;Down, 1&#x3D;Right, 2&#x3D;Up, 3&#x3D;Left      - &#x60;scale&#x60; - Extension scale ratio (1.1 to 3.0, e.g., 1.5 &#x3D; 50% larger in that direction)      - &#x60;remixPrompt&#x60; - Optional prompt to guide the extended content (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The extended images (4 variations) will be sent to your callback URL when complete (typically 90-120 seconds).  ### Use Cases  - Create wider landscape compositions from square images      - Extend portraits to include more environmental context      - Add vertical space for text overlays or additional content      - Build panoramic views from single images      - Adjust aspect ratios for different platform requirements       ### Tips  - Use remixPrompt to specify what should appear in the extended area      - Scale 1.5 is a good starting point (50% extension)      - Higher scales (2.0-3.0) create more new content but may lose coherence      - Works directionally - use outpaint for all-direction expansion      - Can be applied multiple times in different directions
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1PanPostApiResponse"/>&gt;</returns>
        public async Task<IApiV1PanPostApiResponse> ApiV1PanPostAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateApiV1PanPost(xApiKey, body);

                FormatApiV1PanPost(ref xApiKey, ref body);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/pan"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/pan");

                    if (xApiKey.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("x-api-key", ClientUtils.ParameterToString(xApiKey.Value));

                    if (body.IsSet)
                        httpRequestMessageLocalVar.Content = (body.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(body.Value, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ApiV1PanPostApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ApiV1PanPostApiResponse>();
                        ApiV1PanPostApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/pan", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterApiV1PanPostDefaultImplementation(apiResponseLocalVar, xApiKey, body);

                        Events.ExecuteOnApiV1PanPost(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorApiV1PanPostDefaultImplementation(e, "/api/v1/pan", uriBuilderLocalVar.Path, xApiKey, body);
                Events.ExecuteOnErrorApiV1PanPost(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ApiV1PanPostApiResponse"/>
        /// </summary>
        public partial class ApiV1PanPostApiResponse : Org.OpenAPITools.Client.ApiResponse, IApiV1PanPostApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ApiV1PanPostApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ApiV1PanPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1PanPostApiResponse(ILogger<ApiV1PanPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ApiV1PanPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1PanPostApiResponse(ILogger<ApiV1PanPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ApiV1PanPost200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ApiV1PanPost200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ApiV1PanPost200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatApiV1RemixPost(ref Option<string> xApiKey, ref Option<Object> body);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        private void ValidateApiV1RemixPost(Option<string> xApiKey, Option<Object> body)
        {
            if (xApiKey.IsSet && xApiKey.Value == null)
                throw new ArgumentNullException(nameof(xApiKey));

            if (body.IsSet && body.Value == null)
                throw new ArgumentNullException(nameof(body));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void AfterApiV1RemixPostDefaultImplementation(IApiV1RemixPostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<Object> body)
        {
            bool suppressDefaultLog = false;
            AfterApiV1RemixPost(ref suppressDefaultLog, apiResponseLocalVar, xApiKey, body);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void AfterApiV1RemixPost(ref bool suppressDefaultLog, IApiV1RemixPostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<Object> body);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void OnErrorApiV1RemixPostDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<Object> body)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorApiV1RemixPost(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, xApiKey, body);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void OnErrorApiV1RemixPost(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<Object> body);

        /// <summary>
        /// Remix ## Transform Images with New Prompts  Apply a new text prompt to an existing image, transforming it while maintaining aspects of the original composition. Controllable intensity for subtle or dramatic changes.  ### How it Works  Select an image and provide a new prompt. The API applies the new description to the existing image, creating variations that blend the original structure with the new concept. Intensity mode controls how strongly the new prompt is applied.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original image generation task      - &#x60;imageNo&#x60; - Image number to remix (0, 1, 2, or 3)      - &#x60;remixPrompt&#x60; - New prompt to apply to the image (1-8192 characters)      - &#x60;mode&#x60; - Remix intensity: 0&#x3D;Strong (significant transformation), 1&#x3D;Subtle (light transformation)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The remixed images (4 variations) will be sent to your callback URL when complete (typically 90-120 seconds).  ### Use Cases  - Change the style or mood of an existing image      - Apply different artistic directions to the same composition      - Modify time of day, weather, or season in scenes      - Transform realistic images to artistic styles (or vice versa)      - Iterate on concepts by applying different prompts       ### Tips  - Mode 0 (Strong) makes dramatic changes while keeping some structure      - Mode 1 (Subtle) makes gentle modifications, preserving more of the original      - Remix prompt completely replaces the original prompt      - Great for style transfer and conceptual variations      - Experiment with both modes to find the right balance
        /// </summary>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1RemixPostApiResponse"/>&gt;</returns>
        public async Task<IApiV1RemixPostApiResponse?> ApiV1RemixPostOrDefaultAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ApiV1RemixPostAsync(xApiKey, body, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Remix ## Transform Images with New Prompts  Apply a new text prompt to an existing image, transforming it while maintaining aspects of the original composition. Controllable intensity for subtle or dramatic changes.  ### How it Works  Select an image and provide a new prompt. The API applies the new description to the existing image, creating variations that blend the original structure with the new concept. Intensity mode controls how strongly the new prompt is applied.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original image generation task      - &#x60;imageNo&#x60; - Image number to remix (0, 1, 2, or 3)      - &#x60;remixPrompt&#x60; - New prompt to apply to the image (1-8192 characters)      - &#x60;mode&#x60; - Remix intensity: 0&#x3D;Strong (significant transformation), 1&#x3D;Subtle (light transformation)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The remixed images (4 variations) will be sent to your callback URL when complete (typically 90-120 seconds).  ### Use Cases  - Change the style or mood of an existing image      - Apply different artistic directions to the same composition      - Modify time of day, weather, or season in scenes      - Transform realistic images to artistic styles (or vice versa)      - Iterate on concepts by applying different prompts       ### Tips  - Mode 0 (Strong) makes dramatic changes while keeping some structure      - Mode 1 (Subtle) makes gentle modifications, preserving more of the original      - Remix prompt completely replaces the original prompt      - Great for style transfer and conceptual variations      - Experiment with both modes to find the right balance
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1RemixPostApiResponse"/>&gt;</returns>
        public async Task<IApiV1RemixPostApiResponse> ApiV1RemixPostAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateApiV1RemixPost(xApiKey, body);

                FormatApiV1RemixPost(ref xApiKey, ref body);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/remix"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/remix");

                    if (xApiKey.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("x-api-key", ClientUtils.ParameterToString(xApiKey.Value));

                    if (body.IsSet)
                        httpRequestMessageLocalVar.Content = (body.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(body.Value, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ApiV1RemixPostApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ApiV1RemixPostApiResponse>();
                        ApiV1RemixPostApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/remix", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterApiV1RemixPostDefaultImplementation(apiResponseLocalVar, xApiKey, body);

                        Events.ExecuteOnApiV1RemixPost(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorApiV1RemixPostDefaultImplementation(e, "/api/v1/remix", uriBuilderLocalVar.Path, xApiKey, body);
                Events.ExecuteOnErrorApiV1RemixPost(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ApiV1RemixPostApiResponse"/>
        /// </summary>
        public partial class ApiV1RemixPostApiResponse : Org.OpenAPITools.Client.ApiResponse, IApiV1RemixPostApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ApiV1RemixPostApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ApiV1RemixPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1RemixPostApiResponse(ILogger<ApiV1RemixPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ApiV1RemixPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1RemixPostApiResponse(ILogger<ApiV1RemixPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.TaskResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.TaskResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.TaskResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatApiV1RerollPost(ref Option<string> xApiKey, ref Option<Object> body);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        private void ValidateApiV1RerollPost(Option<string> xApiKey, Option<Object> body)
        {
            if (xApiKey.IsSet && xApiKey.Value == null)
                throw new ArgumentNullException(nameof(xApiKey));

            if (body.IsSet && body.Value == null)
                throw new ArgumentNullException(nameof(body));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void AfterApiV1RerollPostDefaultImplementation(IApiV1RerollPostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<Object> body)
        {
            bool suppressDefaultLog = false;
            AfterApiV1RerollPost(ref suppressDefaultLog, apiResponseLocalVar, xApiKey, body);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void AfterApiV1RerollPost(ref bool suppressDefaultLog, IApiV1RerollPostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<Object> body);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void OnErrorApiV1RerollPostDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<Object> body)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorApiV1RerollPost(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, xApiKey, body);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void OnErrorApiV1RerollPost(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<Object> body);

        /// <summary>
        /// Reroll ## Re-execute Task with Same Parameters  Regenerate a new set of images using the exact same parameters as a previous task. This is equivalent to running the original request again with identical settings.  ### How it Works  Provide a previous task&#39;s job ID and the API will execute the same generation with the same prompt and parameters, producing 4 completely new variations.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the task to reroll       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a new task object with different &#x60;job_id&#x60;. The rerolled images (4 new variations) will be sent to your callback URL when complete (typically 60-90 seconds).  ### Use Cases  - Try the same prompt again if initial results didn&#39;t meet expectations      - Generate additional variations without retyping prompts      - Explore different random seeds for the same concept      - Create more options from successful prompts       ### Tips  - Reroll uses the exact same parameters as the original task      - Results will be completely different due to different random seeds      - Consider using variation endpoint instead if you want to build on a specific result      - You can reroll any completed task, even from previous sessions
        /// </summary>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1RerollPostApiResponse"/>&gt;</returns>
        public async Task<IApiV1RerollPostApiResponse?> ApiV1RerollPostOrDefaultAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ApiV1RerollPostAsync(xApiKey, body, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Reroll ## Re-execute Task with Same Parameters  Regenerate a new set of images using the exact same parameters as a previous task. This is equivalent to running the original request again with identical settings.  ### How it Works  Provide a previous task&#39;s job ID and the API will execute the same generation with the same prompt and parameters, producing 4 completely new variations.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the task to reroll       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a new task object with different &#x60;job_id&#x60;. The rerolled images (4 new variations) will be sent to your callback URL when complete (typically 60-90 seconds).  ### Use Cases  - Try the same prompt again if initial results didn&#39;t meet expectations      - Generate additional variations without retyping prompts      - Explore different random seeds for the same concept      - Create more options from successful prompts       ### Tips  - Reroll uses the exact same parameters as the original task      - Results will be completely different due to different random seeds      - Consider using variation endpoint instead if you want to build on a specific result      - You can reroll any completed task, even from previous sessions
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1RerollPostApiResponse"/>&gt;</returns>
        public async Task<IApiV1RerollPostApiResponse> ApiV1RerollPostAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateApiV1RerollPost(xApiKey, body);

                FormatApiV1RerollPost(ref xApiKey, ref body);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/reroll"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/reroll");

                    if (xApiKey.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("x-api-key", ClientUtils.ParameterToString(xApiKey.Value));

                    if (body.IsSet)
                        httpRequestMessageLocalVar.Content = (body.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(body.Value, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ApiV1RerollPostApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ApiV1RerollPostApiResponse>();
                        ApiV1RerollPostApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/reroll", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterApiV1RerollPostDefaultImplementation(apiResponseLocalVar, xApiKey, body);

                        Events.ExecuteOnApiV1RerollPost(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorApiV1RerollPostDefaultImplementation(e, "/api/v1/reroll", uriBuilderLocalVar.Path, xApiKey, body);
                Events.ExecuteOnErrorApiV1RerollPost(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ApiV1RerollPostApiResponse"/>
        /// </summary>
        public partial class ApiV1RerollPostApiResponse : Org.OpenAPITools.Client.ApiResponse, IApiV1RerollPostApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ApiV1RerollPostApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ApiV1RerollPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1RerollPostApiResponse(ILogger<ApiV1RerollPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ApiV1RerollPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1RerollPostApiResponse(ILogger<ApiV1RerollPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.TaskResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.TaskResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.TaskResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatApiV1ShortenPost(ref Option<string> xApiKey, ref Option<Object> body);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        private void ValidateApiV1ShortenPost(Option<string> xApiKey, Option<Object> body)
        {
            if (xApiKey.IsSet && xApiKey.Value == null)
                throw new ArgumentNullException(nameof(xApiKey));

            if (body.IsSet && body.Value == null)
                throw new ArgumentNullException(nameof(body));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void AfterApiV1ShortenPostDefaultImplementation(IApiV1ShortenPostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<Object> body)
        {
            bool suppressDefaultLog = false;
            AfterApiV1ShortenPost(ref suppressDefaultLog, apiResponseLocalVar, xApiKey, body);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void AfterApiV1ShortenPost(ref bool suppressDefaultLog, IApiV1ShortenPostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<Object> body);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void OnErrorApiV1ShortenPostDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<Object> body)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorApiV1ShortenPost(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, xApiKey, body);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void OnErrorApiV1ShortenPost(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<Object> body);

        /// <summary>
        /// Shorten ## Simplify Prompts to Essential Elements  Analyze a long or complex prompt and reduce it to its most essential and impactful elements, maintaining effectiveness while improving clarity.  ### How it Works  Submit a lengthy prompt and the API analyzes it using AI, identifying the most important elements and removing redundancy. Returns multiple shortened variations.  ### Required Parameters  - &#x60;prompt&#x60; - The text prompt to simplify (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The shortened prompt variations will be sent to your callback URL when complete (typically 20-40 seconds).  ### Use Cases  - Optimize overly verbose prompts for better results      - Learn which prompt elements are most impactful      - Reduce token usage in prompt-based workflows      - Clean up accumulated prompt modifications      - Simplify complex prompts for better model understanding       ### Tips  - Particularly useful for prompts over 100 words      - The AI preserves key descriptive elements while removing filler      - Multiple variations help you choose the best simplified version      - Test both original and shortened prompts to compare results      - Great for learning concise prompt writing techniques
        /// </summary>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1ShortenPostApiResponse"/>&gt;</returns>
        public async Task<IApiV1ShortenPostApiResponse?> ApiV1ShortenPostOrDefaultAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ApiV1ShortenPostAsync(xApiKey, body, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Shorten ## Simplify Prompts to Essential Elements  Analyze a long or complex prompt and reduce it to its most essential and impactful elements, maintaining effectiveness while improving clarity.  ### How it Works  Submit a lengthy prompt and the API analyzes it using AI, identifying the most important elements and removing redundancy. Returns multiple shortened variations.  ### Required Parameters  - &#x60;prompt&#x60; - The text prompt to simplify (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The shortened prompt variations will be sent to your callback URL when complete (typically 20-40 seconds).  ### Use Cases  - Optimize overly verbose prompts for better results      - Learn which prompt elements are most impactful      - Reduce token usage in prompt-based workflows      - Clean up accumulated prompt modifications      - Simplify complex prompts for better model understanding       ### Tips  - Particularly useful for prompts over 100 words      - The AI preserves key descriptive elements while removing filler      - Multiple variations help you choose the best simplified version      - Test both original and shortened prompts to compare results      - Great for learning concise prompt writing techniques
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1ShortenPostApiResponse"/>&gt;</returns>
        public async Task<IApiV1ShortenPostApiResponse> ApiV1ShortenPostAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateApiV1ShortenPost(xApiKey, body);

                FormatApiV1ShortenPost(ref xApiKey, ref body);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/shorten"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/shorten");

                    if (xApiKey.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("x-api-key", ClientUtils.ParameterToString(xApiKey.Value));

                    if (body.IsSet)
                        httpRequestMessageLocalVar.Content = (body.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(body.Value, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ApiV1ShortenPostApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ApiV1ShortenPostApiResponse>();
                        ApiV1ShortenPostApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/shorten", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterApiV1ShortenPostDefaultImplementation(apiResponseLocalVar, xApiKey, body);

                        Events.ExecuteOnApiV1ShortenPost(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorApiV1ShortenPostDefaultImplementation(e, "/api/v1/shorten", uriBuilderLocalVar.Path, xApiKey, body);
                Events.ExecuteOnErrorApiV1ShortenPost(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ApiV1ShortenPostApiResponse"/>
        /// </summary>
        public partial class ApiV1ShortenPostApiResponse : Org.OpenAPITools.Client.ApiResponse, IApiV1ShortenPostApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ApiV1ShortenPostApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ApiV1ShortenPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1ShortenPostApiResponse(ILogger<ApiV1ShortenPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ApiV1ShortenPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1ShortenPostApiResponse(ILogger<ApiV1ShortenPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.TaskResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.TaskResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.TaskResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatApiV1UpscalePost(ref Option<string> xApiKey, ref Option<Object> body);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        private void ValidateApiV1UpscalePost(Option<string> xApiKey, Option<Object> body)
        {
            if (xApiKey.IsSet && xApiKey.Value == null)
                throw new ArgumentNullException(nameof(xApiKey));

            if (body.IsSet && body.Value == null)
                throw new ArgumentNullException(nameof(body));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void AfterApiV1UpscalePostDefaultImplementation(IApiV1UpscalePostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<Object> body)
        {
            bool suppressDefaultLog = false;
            AfterApiV1UpscalePost(ref suppressDefaultLog, apiResponseLocalVar, xApiKey, body);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void AfterApiV1UpscalePost(ref bool suppressDefaultLog, IApiV1UpscalePostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<Object> body);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void OnErrorApiV1UpscalePostDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<Object> body)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorApiV1UpscalePost(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, xApiKey, body);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void OnErrorApiV1UpscalePost(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<Object> body);

        /// <summary>
        /// Upscale ## Enhance Image Resolution and Quality  Upscale and enhance one of your generated images to higher resolution with AI-powered quality improvement. Produces a single high-resolution version of the selected image.  ### How it Works  Select one image from a generation task and choose upscaling type. The API processes the image to increase resolution while adding detail and clarity based on the selected upscaling mode.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original image generation task      - &#x60;imageNo&#x60; - Image number to upscale (0, 1, 2, or 3)      - &#x60;type&#x60; - Upscaling type: 0&#x3D;Subtle (conservative enhancement), 1&#x3D;Creative (adds detail and interpretation)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The upscaled image (single high-resolution output) will be sent to your callback URL when complete (typically 90-120 seconds).  ### Use Cases  - Prepare images for print or high-resolution displays      - Enhance selected variations for final delivery      - Create detailed versions for client presentations      - Generate production-ready assets from generations       ### Tips  - Type 0 (Subtle) is safer for preserving exact details      - Type 1 (Creative) works well for artistic images where added interpretation is acceptable      - Upscaling is typically the final step after selecting your preferred variation      - Output resolution is significantly higher than the original 4-image grid
        /// </summary>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1UpscalePostApiResponse"/>&gt;</returns>
        public async Task<IApiV1UpscalePostApiResponse?> ApiV1UpscalePostOrDefaultAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ApiV1UpscalePostAsync(xApiKey, body, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Upscale ## Enhance Image Resolution and Quality  Upscale and enhance one of your generated images to higher resolution with AI-powered quality improvement. Produces a single high-resolution version of the selected image.  ### How it Works  Select one image from a generation task and choose upscaling type. The API processes the image to increase resolution while adding detail and clarity based on the selected upscaling mode.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original image generation task      - &#x60;imageNo&#x60; - Image number to upscale (0, 1, 2, or 3)      - &#x60;type&#x60; - Upscaling type: 0&#x3D;Subtle (conservative enhancement), 1&#x3D;Creative (adds detail and interpretation)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a task object. The upscaled image (single high-resolution output) will be sent to your callback URL when complete (typically 90-120 seconds).  ### Use Cases  - Prepare images for print or high-resolution displays      - Enhance selected variations for final delivery      - Create detailed versions for client presentations      - Generate production-ready assets from generations       ### Tips  - Type 0 (Subtle) is safer for preserving exact details      - Type 1 (Creative) works well for artistic images where added interpretation is acceptable      - Upscaling is typically the final step after selecting your preferred variation      - Output resolution is significantly higher than the original 4-image grid
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1UpscalePostApiResponse"/>&gt;</returns>
        public async Task<IApiV1UpscalePostApiResponse> ApiV1UpscalePostAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateApiV1UpscalePost(xApiKey, body);

                FormatApiV1UpscalePost(ref xApiKey, ref body);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/upscale"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/upscale");

                    if (xApiKey.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("x-api-key", ClientUtils.ParameterToString(xApiKey.Value));

                    if (body.IsSet)
                        httpRequestMessageLocalVar.Content = (body.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(body.Value, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ApiV1UpscalePostApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ApiV1UpscalePostApiResponse>();
                        ApiV1UpscalePostApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/upscale", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterApiV1UpscalePostDefaultImplementation(apiResponseLocalVar, xApiKey, body);

                        Events.ExecuteOnApiV1UpscalePost(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorApiV1UpscalePostDefaultImplementation(e, "/api/v1/upscale", uriBuilderLocalVar.Path, xApiKey, body);
                Events.ExecuteOnErrorApiV1UpscalePost(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ApiV1UpscalePostApiResponse"/>
        /// </summary>
        public partial class ApiV1UpscalePostApiResponse : Org.OpenAPITools.Client.ApiResponse, IApiV1UpscalePostApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ApiV1UpscalePostApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ApiV1UpscalePostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1UpscalePostApiResponse(ILogger<ApiV1UpscalePostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ApiV1UpscalePostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1UpscalePostApiResponse(ILogger<ApiV1UpscalePostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.TaskResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.TaskResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.TaskResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatApiV1VariationPost(ref Option<string> xApiKey, ref Option<Object> body);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        /// <returns></returns>
        private void ValidateApiV1VariationPost(Option<string> xApiKey, Option<Object> body)
        {
            if (xApiKey.IsSet && xApiKey.Value == null)
                throw new ArgumentNullException(nameof(xApiKey));

            if (body.IsSet && body.Value == null)
                throw new ArgumentNullException(nameof(body));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void AfterApiV1VariationPostDefaultImplementation(IApiV1VariationPostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<Object> body)
        {
            bool suppressDefaultLog = false;
            AfterApiV1VariationPost(ref suppressDefaultLog, apiResponseLocalVar, xApiKey, body);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void AfterApiV1VariationPost(ref bool suppressDefaultLog, IApiV1VariationPostApiResponse apiResponseLocalVar, Option<string> xApiKey, Option<Object> body);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        private void OnErrorApiV1VariationPostDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<Object> body)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorApiV1VariationPost(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, xApiKey, body);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xApiKey"></param>
        /// <param name="body"></param>
        partial void OnErrorApiV1VariationPost(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> xApiKey, Option<Object> body);

        /// <summary>
        /// Variation ## Create Controlled Variations of Existing Images  Generate new variations of a specific image from a previous generation task with controllable transformation intensity. Perfect for exploring different interpretations while maintaining the core composition.  ### How it Works  Select one of the 4 generated images from a diffusion task and create variations with either subtle or strong intensity. The API generates 4 new variations based on your selected image and intensity setting.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original image generation task      - &#x60;imageNo&#x60; - Image number to vary (0, 1, 2, or 3)      - &#x60;type&#x60; - Variation intensity: 0&#x3D;Subtle (minor changes), 1&#x3D;Strong (major changes)      - &#x60;remixPrompt&#x60; - Optional additional prompt for guided variation (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a new task object with &#x60;job_id&#x60;. The 4 variation images will be sent to your callback URL when processing completes (typically 60-90 seconds).  ### Use Cases  - Explore different interpretations of a successful generation      - Fine-tune specific aspects of an image      - Create multiple versions for A/B testing      - Generate variations for client review      - Remix images with additional prompt guidance       ### Tips  - Use type&#x3D;0 (subtle) for minor refinements, type&#x3D;1 (strong) for significant changes      - Add remixPrompt to guide the variation in a specific direction      - The original composition and structure are generally preserved      - Can chain variations: create variations of variations for iterative refinement
        /// </summary>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1VariationPostApiResponse"/>&gt;</returns>
        public async Task<IApiV1VariationPostApiResponse?> ApiV1VariationPostOrDefaultAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ApiV1VariationPostAsync(xApiKey, body, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Variation ## Create Controlled Variations of Existing Images  Generate new variations of a specific image from a previous generation task with controllable transformation intensity. Perfect for exploring different interpretations while maintaining the core composition.  ### How it Works  Select one of the 4 generated images from a diffusion task and create variations with either subtle or strong intensity. The API generates 4 new variations based on your selected image and intensity setting.  ### Required Parameters  - &#x60;jobId&#x60; - UUID of the original image generation task      - &#x60;imageNo&#x60; - Image number to vary (0, 1, 2, or 3)      - &#x60;type&#x60; - Variation intensity: 0&#x3D;Subtle (minor changes), 1&#x3D;Strong (major changes)      - &#x60;remixPrompt&#x60; - Optional additional prompt for guided variation (1-8192 characters)       ### Authentication  Requires a valid API key passed in the &#x60;x-api-key&#x60; header.  ### Response  Returns a new task object with &#x60;job_id&#x60;. The 4 variation images will be sent to your callback URL when processing completes (typically 60-90 seconds).  ### Use Cases  - Explore different interpretations of a successful generation      - Fine-tune specific aspects of an image      - Create multiple versions for A/B testing      - Generate variations for client review      - Remix images with additional prompt guidance       ### Tips  - Use type&#x3D;0 (subtle) for minor refinements, type&#x3D;1 (strong) for significant changes      - Add remixPrompt to guide the variation in a specific direction      - The original composition and structure are generally preserved      - Can chain variations: create variations of variations for iterative refinement
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xApiKey"> (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IApiV1VariationPostApiResponse"/>&gt;</returns>
        public async Task<IApiV1VariationPostApiResponse> ApiV1VariationPostAsync(Option<string> xApiKey = default, Option<Object> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateApiV1VariationPost(xApiKey, body);

                FormatApiV1VariationPost(ref xApiKey, ref body);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/v1/variation"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/v1/variation");

                    if (xApiKey.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("x-api-key", ClientUtils.ParameterToString(xApiKey.Value));

                    if (body.IsSet)
                        httpRequestMessageLocalVar.Content = (body.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(body.Value, _jsonSerializerOptions));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ApiV1VariationPostApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ApiV1VariationPostApiResponse>();
                        ApiV1VariationPostApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/v1/variation", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterApiV1VariationPostDefaultImplementation(apiResponseLocalVar, xApiKey, body);

                        Events.ExecuteOnApiV1VariationPost(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorApiV1VariationPostDefaultImplementation(e, "/api/v1/variation", uriBuilderLocalVar.Path, xApiKey, body);
                Events.ExecuteOnErrorApiV1VariationPost(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ApiV1VariationPostApiResponse"/>
        /// </summary>
        public partial class ApiV1VariationPostApiResponse : Org.OpenAPITools.Client.ApiResponse, IApiV1VariationPostApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ApiV1VariationPostApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ApiV1VariationPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1VariationPostApiResponse(ILogger<ApiV1VariationPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ApiV1VariationPostApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ApiV1VariationPostApiResponse(ILogger<ApiV1VariationPostApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.TaskResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.TaskResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.TaskResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
